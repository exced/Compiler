-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,OPUN,OPMUL,OPREL,OPADD
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- attributs relatifs fonction
inh etiquette : STRING for DECL, FONCTION;

-- la TDS courante
inh tds_asm : TDS for ASM;
inh tds    : TDS     for BLOC, ENTITE,ENTITES, INSTS, INST, FONCTION, DECL, PARFS, PARF, PARFSX, SIX ,E,ES,ESX,F,FX,T,TX,R,RX,A,AFFX,AX;
syn code : STRING for ENTITE , ENTITES, F,FX, BLOC,SIX, INSTS, INST, E, AFFX,OPUN,OPMUL,OPREL,OPADD,T,TX,A,AX,R,RX;
--inh hcode : STRING for ;
syn type : DTYPE for F,FX, TYPE,E, STYPE,PTRS, AFFX, A,AX, R,RX,T,TX,OPADD, OPMUL,OPUN,OPREL;
inh hdep : INTEGER for BLOC, INSTS, INST , CHAMPS, CHAMP,FX;
syn dep : INTEGER for INST , INSTS;
inh champs : LCHAMPS for CHAMPS, CHAMP;
syn code_est_adresse : BOOLEAN for  F, FX, A,AX,R,RX,T,TX,E ;
inh hcode_est_adresse : BOOLEAN for FX,AFFX ;
-- Cet attribut sert a calculer les adresses STATIQUEMENT
-- lorsque cela est possible. Vaut 0 si valeur non significative.
-- Cet attribut est calcule systématiquement en attendant de
-- savoir s'il est utile ou non ...
syn adresse : INTEGER for  F, FX, A,R,T,E; 
inh hadresse : INTEGER for FX ,AFFX;

-- gestion des types pour les opérateurs, affectation etc
inh htype : DTYPE for  AFFX,AX,FX,RX,TX;

-- gestion de l'affectation
syn est_affectable : BOOLEAN for A,T,R,F,E,FX;



--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init #tds ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#tds {
do
    --init de la TDS
    ENTITES^tds := new TDS(nil);
end
}
-- ecrit le code dans un fichier
global
    code : String;
#gen {
local
do
   -- on suppose la methode "int main()" existante, et sans parametres
   code := machine.genCall("main") + ENTITES^code + machine.genFin();
   -- generation du code de fin du programme
   machine.writeCode(PROGRAMME^source.getFileName(), code);  
end
}

ENTITES -> #gen ;
#gen {
do
    ENTITES^code := "";
end
}


ENTITES ->  ENTITE ENTITES #gen;
#gen {
do
    ENTITES^code := ENTITE^code + ENTITES1^code;
end
}    
-- TDS Done

-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds #gen;
#tds {
local
    i : INFO ;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    if i /= null then
       error(B_01, identc^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      ENTITE^tds.inserer(identc^txt,  i);
    end
end
}
#gen {
do
    ENTITE^code := "";        
end
}


-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
ENTITE ->  TYPE ident #tds #nomFonction DECL #gen;
#tds {
local
    i : INFO ;
do
    i := ENTITE^tds.chercherGlobalement(ident^txt);
    if i /= null then
       error(B_02, ident^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      ENTITE^tds.inserer(ident^txt,  i);
    end
    -- transmission tds
    DECL^tds := ENTITE^tds;
end
}
#nomFonction {
do
    DECL^etiquette := ident^txt;
end
}
#gen {
do 
    ENTITE^code := "";
end
}


-- Variable
DECL -> pv ;

-- déclaration d'une fonction
DECL -> FONCTION ;
--TDS Done

-- Fonction
FONCTION -> #tailleRetour paro #tds PARFS parf BLOC #gen;
global
    tdsParam : TDS;
    tam : IMachine;
    tailleRetour : INTEGER;
#tailleRetour {
 local
    i : INFO ;
    it : INFOTYPE;
    t : DTYPE;
 do
    -- rechercher l'ident   
    i := FONCTION^tds.chercherGlobalement(FONCTION^etiquette);
    if i = nil then
      error(B_05, FONCTION^etiquette);
    else
        tailleRetour := i.getTaille();
    end
end
}    
#tds {
do
    tdsParam := new TDS(FONCTION^tds);
    PARFS^tds := tdsParam; 
    BLOC^tds := new TDS(tdsParam);
    BLOC^hdep := 3;
end
}
#gen{
local
  cp : STRING ; -- code sous la forme d'une fonction
do
    tam := FONCTION^machine;
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    cp := tam.genFonction(FONCTION^etiquette, tdsParam.getTailleParams(), tailleRetour, BLOC^code);
end
}

-- parametres de fonctions
PARFS ->  ;
-- Done


-- 
-- multi paramètres
PARFS -> #tds PARF PARFSX ;
global
    tds:TDS;
#tds {
do
    tds := new TDS(PARFS^tds);
    PARF^tds := tds;
    PARFSX^tds := tds;
end
}


PARFSX ->  ;
-- Done


PARFSX -> #tds virg PARF PARFSX ;
#tds {
do 
    -- transmission des tds;
    PARF^tds := PARFSX^tds;
    PARFSX1^tds := PARFSX^tds;
end
}

-- type
PARF -> TYPE ident #tds;
#tds {
local
    i : INFO ;
do
    -- inserer les autres param dans la tds des param
    i := PARF^tds.chercherGlobalement(ident^txt);
    if i /= null then
       error(B_02, ident^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      PARF^tds.inserer(ident^txt,  i);
    end
end
}

-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE PTRS #type;
#type {
do
    if PTRS^type = nil then
        TYPE^type := STYPE^type;
    else
        TYPE^type := new POINTEUR(PTRS^type) ;
    end    
end
}

-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type {
do
    PTRS^type := nil;
end
}

-- variable qualifiee 
PTRS -> mult PTRS #type;
#type {
do
    PTRS^type := new POINTEUR(PTRS1^type);
end
}

-- types de base
STYPE-> void #type ;
#type {
do
    STYPE^type := new DTYPE("void");
end
}

STYPE-> int #type;
#type {
do
    STYPE^type := new DTYPE("int");
end
}

STYPE-> char #type;
#type {
do
    STYPE^type := new DTYPE("char");
end
}

-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
do
    STYPE^type := new DTYPE(identc^txt);
end
}

-------------  
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type;
global 
 lc : LCHAMPS ;
#ch {
do
  lc := new LCHAMPS();
  CHAMPS^champs := lc;
  CHAMPS^hdep := 0;
end
}
#type {
 do
   STYPE^type := new STRUCT(lc);
 end
}


CHAMPS -> ;
-- Done

-- un nom de champ commence par une minuscule
CHAMPS ->  CHAMP CHAMPS ;
--Done

CHAMP -> TYPE ident pv #champ;
#champ {
 local
  c : CHAMP ;
 do
  c := CHAMP^champs.chercher(ident^txt);
    if c /= null then
       error(B_00, ident^txt);
    else    
      c := new CHAMP(ident^txt, TYPE^type, CHAMP^hdep);
     CHAMP^champs.inserer(c);
    end
 end
}


-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS acf #gen;
global        -- globale aux actions de cette regle
  t : TDS;    -- pour voir la TDS du bloc
#tds {
do
   t :=  new TDS(BLOC^tds);
   INSTS^tds := t;
end
}
#gen {
do
   write "; tds:\n" + t;
   write "; taille des locales = " + (INSTS^dep - BLOC^hdep)+ "\n";
   BLOC^code := INSTS^code + BLOC^machine.genFree(INSTS^dep - BLOC^hdep);
end
}

-- instructions --
INSTS ->  #gen ;
#gen {
do
  INSTS^dep := INSTS^hdep ;
  INSTS^code := "";
end
}

INSTS ->  INST #dep INSTS #gen ;
#dep {
do
  INSTS1^hdep := INST^dep;
end
}
#gen {
do
  INSTS^dep := INSTS1^dep;
  INSTS^code := INST^code + INSTS1^code;
end
}

-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident #htype AFFX pv #tds #type #gen ;
#tds {
local
    i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(B_00, ident^txt);
    else    
      -- creer un type
     i := new INFOTYPE(TYPE^type);
     call INST^tds.inserer(ident^txt,  i);
     INST^dep := INST^hdep ;
    end
end
}
#htype {
do
    -- transmission de type
    AFFX^htype := TYPE^type;
    -- transmission de l adresse
    AFFX^hcode_est_adresse := false;
    AFFX^hadresse := "";
end
}
#type {
do
    -- controle de type
   if ~TYPE^type.compareTo(AFFX^type) then
      error(B_11, TYPE^type, AFFX^type);
   end
   
   --controle de type retour-decl
end
}
#gen {
do
    -- MODIFIE
    INST^code := AFFX^code;
end
}

-- instruction expression (affectation et appel de procedure)
INST -> E pv #gen;
#gen {
do
    -- le code dépend de s'il y a eu affectation ou appel
    INST^code := E^code;
    INST^dep := 0;
end
}


-- bloc d'instructions
INST -> #dep BLOC  #code;
#dep {
do
    -- CA SORT D OU
    BLOC^hdep := 3;
    INST^dep := 3;
end
}
#code {
do
    INST^code := BLOC^code;        
end
}



-- conditionnelle
INST ->  si paro E #type parf BLOC SIX #gen;
#type {
do
   if ~E^type.compareTo(new DTYPE("INT", 4)) then
      error(B_04, E^type);
   end
end
}
#gen {
do
    INST^dep := INST^hdep;
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;
end
}

-- bloc sinon 
SIX ->    sinon #hdep BLOC #gen;
#hdep {
do
    BLOC^hdep := 3;
end
}
#gen {
do
    SIX^code := BLOC^code;
end
}

-- pas de bloc sinon
SIX -> #gen;
#gen{
do
    SIX^code := "";
end
}


-- retour de fonction
INST ->  retour E pv #type #gen;
#type {
do
    -- remontee du type de retour pour le controle
end
}
#gen {
do
    INST^code := E^code;
    INST^dep := 0;
end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

E -> #tds A #aff #type AFFX #gen;
#tds {
-- transmission tds
do
    A^tds := E^tds;
    AFFX^tds := E^tds;

end
}
#aff {
do
    E^code_est_adresse := A^code_est_adresse;
    if A^code_est_adresse then
        E^adresse := A^adresse;
    else
        E^adresse := "";
    end    
    -- transmission du bool hcode est adresse
    AFFX^hcode_est_adresse := A^code_est_adresse;
    -- transmission de l adresse de A pour la GC lors de l affectation
    AFFX^hadresse := A^adresse;
    --gestion d'erreur en cas de probleme d affectation
    if ~A^est_affectable then
        error(B_14);
    else
        E^est_affectable := A^est_affectable;
    end
end
}
#type {
do
    E^type := A^type;
    -- type pour permettre le controle d'erreur au moment de l'affectation
    AFFX^htype := A^type;
end
}
#gen {
do
    E^code := AFFX^code;  
end
}

-- affectation
AFFX -> affect #tds A  #type #gen;
#tds {
-- transmission tds
do
    A^tds := AFFX^tds;
end
}

#type {
-- controle de type
do
    -- remonter le type pour la declaration avec affectation
    AFFX^type := AFFX^htype;
    
    if ~A^type.compareTo(AFFX^htype) then
        error(B_10, A^type.getNom());
    end
end
}
#gen {
local 
  code : STRING;
do
    if ~AFFX^htype.compareTo(A^type) then
      error(B_02, AFFX^htype, A^type);
    else
    
      code :=  AFFX^machine.genComment("Valeur") + A^code ;
      if AFFX^hcode_est_adresse then
        code := code + AFFX^machine.genComment("Adresse") +
                     A^code + AFFX^machine.genWriteIndirectMem(AFFX^htype.getTaille());
      else
        code := code + AFFX^machine.genWriteMem(AFFX^hadresse, AFFX^htype.getTaille());
       end 
      AFFX^code := code; 
                         
     end
  end
}

AFFX ->#type #gen;
#type {
do
    AFFX^type := AFFX^htype;
end
}
#gen {
do
    AFFX^code := "";
end
}

-- relation
A -> #tds R #aff #type AX #gen;
#tds {
do
    R^tds := A^tds;
end
}
#aff {
do
    A^est_affectable := R^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    AX^htype := R^type;
    -- on remonte le type
    A^type := R^type;
end
}
#gen {
local
    est_adresse : BOOL;
do
    -- generation du code qui renvoie la valeur correspond a la relation
    A^code := R^code + AX^code;
    est_adresse := (R^code_est_adresse && AX^code_est_adresse);
    A^code_est_adresse := est_adresse;
    if est_adresse then
        A^adresse := R^adresse;
    else
        A^adresse := "";
    end        
end
}

AX -> OPREL #tds R #type #gen;
#tds {
do
    R^tds := AX^tds;
end
}
#type {
do
    -- controle de type
    if ~AX^htype.compareTo(OPREL^type, R^type) then
        error(B_10, AX^htype.getNom());
    else
    -- on remonte le type
        AX^type := R^type;         
    end 
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur relationnel
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    AX^code := R^code + OPREL^code;     
    -- membre de droite lors de la relation -> ce n est pas une adresse
    AX^code_est_adresse := false;
end
}



AX ->  #type #gen;
#type {
do
    AX^type := AX^htype;
    -- pas de membre de droite lors de la relation -> adresse possible
    AX^code_est_adresse := true;
end
}
#gen {
do
    AX^code := "";
end
}

-- operateurs relationnels
OPREL -> inf #type;
#type {
do
    OPREL^type := new DTYPE("OPRELINF");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILss");
end
}

OPREL -> sup #type;
#type {
do
    OPREL^type := new DTYPE("OPRELSUP");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGtr");    
end
}
OPREL -> infeg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELINFEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILeq");    
end
}

OPREL -> supeg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELSUPEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGeq");    
end
}

OPREL -> eg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IEq");    
end
}

OPREL -> neg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELNEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("INeq");    
end
}

-- additions multiples
R -> #tds T #aff #type RX #gen;
#tds {
do
    T^tds := R^tds;
end
}
#aff {
do
    R^est_affectable := T^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    RX^htype := T^type;
    -- on remonte le type
    R^type := T^type;
end
}
#gen {
local
    est_adresse : BOOL;
do
    -- generation du code qui renvoie la valeur correspond a la relation
    R^code := T^code + RX^code;
    est_adresse := (T^code_est_adresse && RX^code_est_adresse);
    R^code_est_adresse := est_adresse;
    if est_adresse then
        R^adresse := T^adresse;
    else
        R^adresse := "";
    end        
end
}


-- additions ...
RX ->   OPADD  T RX  #type #gen;
#type {
do
    -- controle de type
    if ~RX^htype.compareTo(OPADD^type, T^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, T^type);    
    elseif ~RX^htype.compareTo(OPADD^type, RX1^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, RX1^type);
    else
    -- on remonte le type
        RX^type := T^type;         
    end 
end
}
#gen {
do
    -- opadd donc ce n est plus une adresse
    RX^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur add
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    RX^code := T^code + RX1^code + OPADD^code;         
end
}



RX -> #type;
#type {
do
    RX^type := RX^htype;
    -- adresse
    RX^code_est_adresse := true;
    -- GC
    RX^code := "";
end
}

-- operateurs additifs
OPADD -> plus #type;
#type {
do
    OPADD^type := new DTYPE("OPADDPLUS");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("IAdd");     
end
}

OPADD -> moins #type;
#type {
do
    OPADD^type := new DTYPE("OPADDMOINS");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("ISub");     
end
}

OPADD -> ou #type;
#type {
do
    OPADD^type := new DTYPE("OPADDOU");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("BOr");     
end
}

-- multiplication, ...
T -> #tds F #aff #type TX #gen ;
#tds {
do
    F^tds := T^tds;
end
}
#aff {
do
    T^est_affectable := F^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    TX^htype := F^type;
    -- on remonte le type
    T^type := F^type;
end
}
#gen {
local
    est_adresse : BOOL;
do
    -- generation du code qui renvoie la valeur correspond a la relation
    T^code := F^code + TX^code;
    est_adresse := (F^code_est_adresse && TX^code_est_adresse);
    T^code_est_adresse := est_adresse;
    if est_adresse then
        T^adresse := F^adresse;
    else
        T^adresse := "";
    end        
end
}

TX -> OPMUL #tds F TX  #type #gen;
#tds {
do
    TX1^tds := TX^tds;
end
}
#type {
do
    -- controle de type
    if ~TX^htype.compareTo(OPMUL^type, F^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, F^type);    
    elseif ~TX^htype.compareTo(OPMUL^type, TX1^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, TX1^type);
    else
    -- on remonte le type
        TX^type := F^type;     
    end
    
    -- opmul donc ce n est plus une adresse
    TX^code_est_adresse := false; 
  
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur multiple
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    TX^code := F^code + TX1^code + OPMUL^code;    
end
}

TX -> #type ;
#type {
do
    TX^type := TX^htype;
    TX^code := "";
    
    -- pas de opmul donc le code peut etre une adresse
    TX^code_est_adresse := true;
end
}


-- operateurs multiplicatifs
OPMUL -> mult #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULMULT");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMul");    
end
}

OPMUL -> div #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULDIV");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IDiv");      
end
}

OPMUL -> mod #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULMOD");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMod");      
end
}

OPMUL -> et #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULET");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("BAnd");      
end
}

-- expressions de base

-- Constante entiere --
F -> entier #aff #gen ;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(entier^txt);
    F^adresse := 0;
end
}

-- Constante chaine
F -> chaine #aff #gen;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genChaine(chaine^txt);
    F^adresse := 0;
end
}


-- Constante caractere
F -> caractere #aff #gen;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCaractere(caractere^txt);
    F^adresse := 0;
end
}


-- expression unaire
F -> #aff OPUN  F #type #gen;
#aff {
do
    -- non affectable car operation unaire
    F^est_affectable := false;
end
}
#type {
do
    -- controle de type
    if ~F1^type.compareTo(OPUN^type) then
        error(B_10, OPUN^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := F1^type;         
    end 
  
end
}
#gen {
do
    F^code_est_adresse := false;
    F^adresse := F1^adresse;
    -- remontee du code pour prendre en compte l operateur unaire
    -- on empile d abord la valeur puis on fait un SUBR op
    F^code := F1^code + OPUN^code;
end
}

-- operateurs unaires
OPUN -> plus #type;
#type {
do
    OPUN^type := new DTYPE("OPUNPLUS");
    -- SUBR op
    OPUN^code := "";
end
}

OPUN -> moins #type;
#type {
do
    OPUN^type := new DTYPE("OPUNMOINS");
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("Ineg");
end
}

OPUN -> non #type;
#type {
do
    OPUN^type := new DTYPE("OPUNNON");
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("BNeg");    
end
}

-- pointeur NULL
F -> null #aff #type ;
#aff {
do
    -- non affectable car pointeur null
    F^est_affectable := false;
end
}
#type {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := "";
    F^adresse := -1;
end
}


-- expression parenthesee
F ->  paro E parf FX #aff #type #gen;
#aff {
do
    F^est_affectable := (E^est_affectable && FX^est_affectable);
end
}
#type {
do
    -- controle de type
    if ~E^type.compareTo(FX^type) then
        error(B_12, E^type.getNom(), FX^type.getNom());
    else
    -- on remonte le type
        F^type := E^type;         
    end 
  
end
}
#gen {
local
    est_adresse : BOOL;
do
    est_adresse := (E^code_est_adresse && FX^code_est_adresse);
    F^code_est_adresse := est_adresse;
    if est_adresse then
        F^adresse := E^adresse;
    else
        F^adresse := "";
    end        
    
    -- GC
    F^code := E^code + FX^code;
end
}


F ->  paro TYPE parf  F #aff #type;
#aff {
do
    F^est_affectable := F1^est_affectable;
end
}
#type {
do
    -- controle de type
    if ~TYPE^type.compareTo(F^type) then
        error(B_12, TYPE^type.getNom(), F^type.getNom());
    else
    -- on remonte le type
        F^type := TYPE^type;         
    end 
  
end
}


F -> mult F #aff #type #addr;
#aff {
do
    F^est_affectable := F1^est_affectable;
end
}
#type {
do
    -- controle de type
    if ~F1^type.compareTo(F^type) then
        error(B_12, F^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := new POINTEUR(F1^type);         
    end         
end
}
#addr {
do
    F^adresse := F1^adresse;
end
}


F -> ident FX #aff #gen;
global 
  iv : INFOVAR ;
  t : DTYPE;
#aff {
do
    F^est_affectable := FX^est_affectable;
end
}  
#gen{
local
  i:INFO;
  code : STRING;
do
  i := F^tds.chercherGlobalement(ident^txt);
  if i = null then
    error(B_01, ident^txt);
  end
  match i 
  with INFOVAR then
    iv := i;
    t := iv.getType();
    F^type := t;
    F^code := FX^code;
    F^code_est_adresse := FX^code_est_adresse;
  else
    error(B_08, ident^txt);
  end
end
}

FX -> #aff #gen;
#aff {
do
    FX^est_affectable := true;
end
}
#gen {
do
  FX^type := FX^htype;
  FX^code_est_adresse := FX^hcode_est_adresse;
  FX^code := FX^hcode;
  FX^adresse := FX^hadresse;
end
}

-- acces champ
FX ->   pt  ident #a FX #aff #gen;
#aff {
do
    FX^est_affectable := FX1^est_affectable;
end
}
#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=FX1^code;
  FX^adresse := FX1^adresse;
end
}
#a {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do
  match FX^htype
  with STRUCT then
    s := FX^htype;
    lc := s.getChamps();
    c := lc.chercher(ident^txt);
    if c = null then
      error(B_10, ident^txt) ;
    else
      FX1^htype := c.getType();
      --FX1^hcode_est_adresse := FX^hcode_est_adresse;
      if ! FX^hcode_est_adresse then
        FX1^hadresse := 0;
        FX1^hcode :=FX^hcode + FX^machine.genComment("acces champ : " + ident^txt) +
                  FX^machine.genAdrField(c.getDep())  ;
      else
        FX1^hadresse := FX^hadresse + c.getDep();
        FX1^hcode := FX^machine.genComment("acces champ : " + ident^txt);
      end
    end    
  else
    error(B_09, FX^htype); 
  end

end
}

-- acces champ pointeur
FX ->   arrow  ident FX #aff #type #gen;
#aff {
do
    FX^est_affectable := FX1^est_affectable;
end
}
#type {
do
    
end
}
#gen {
do
        
end
}

-- appel de sous-programme
FX ->   paro #tds ES parf FX #aff #gen;
global 
    tdsParam :  TDS;
#aff {
do
    -- pour l instant on ne gere pas l affectation multiple
    FX^est_affectable := false;
end
}    
#tds {
do
    --création d'une TDS pour stocker les param de l'appel
    tdsParam := new TDS(FX^tds);
    ES^tds := tdsParam; 
    FX1^tds := new TDS(tdsParam);
    FX1^hdep := 3;
end
}
#gen {
do
    -- appel du sous-programme à partir de l'étiquette
    FX^code := FX^machine.genCall();
end
}

-- arguments appel de sous-programme
ES -> ;
-- Done


ES -> #tds E ESX  ;
global
    tds:TDS;
#tds {
do
    tds := new TDS(ES^tds);
    E^tds := tds;
    ESX^tds := tds;
end
}

ESX ->  ;
-- Tds done


ESX -> #tds virg E ESX ;
#tds {
do 
    -- transmission des tds;
    E^tds := ESX^tds;
    ESX1^tds := ESX^tds;
end
}

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^code := ASM^code_asm;
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
