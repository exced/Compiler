-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- attributs relatifs fonction
inh identDecl : STRING for DECL, FONCTION;

-- la TDS courante
inh tds_asm : TDS for ASM;
inh tds    : TDS     for BLOC, ENTITE,ENTITES, INSTS, INST, FONCTION, DECL, PARFS, PARF, PARFSX ;
syn code : STRING for PROGRAMME,ENTITE , ENTITES, F, BLOC, INSTS, INST, E, OPUN;
inh hcode : STRING for FX;
syn type : DTYPE for F, TYPE, STYPE,OPUN, OPMUL,OPREL,PTRS, AFFX, A;
inh hdep : INTEGER for BLOC, INSTS, INST , CHAMPS;
syn dep : INTEGER for INST , INSTS;
inh champs : LCHAMPS for CHAMPS, CHAMP;
syn code_est_adresse : BOOLEAN for  FACTEUR, FX ;
inh hcode_est_adresse : BOOLEAN for FX ;
-- Cet attribut sert a calculer les adresses STATIQUEMENT
-- lorsque cela est possible. Vaut 0 si valeur non significative.
-- Cet attribut est calcule systématiquement en attendant de
-- savoir s'il est utile ou non ...
syn adresse : INTEGER for  F, FX ; 
inh hadresse : INTEGER for FX ;
-- on pourrait utiliser une valeur particulière (c'est-a-dire non valide !)
-- de l'adresse pour indiquer qu'on ne tient pas compte de l'adresse
-- mais il vaut mieux utiliser un booleen adresse_utile
syn adresse_utile : BOOLEAN for  F, FX ; 
inh hadresse_utile : BOOLEAN for FX ;


--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init #tds ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#tds {
do
    --init de la TDS
    ENTITES^tds := new TDS(nil);
end
}
-- ecrit le code dans un fichier
global
    code : String;
#gen {
local
do
   code := ENTITES^code;
   -- generation du code de fin du programme
   code := code + "\nHALT";
   PROGRAMME^code := code;
   machine.writeCode(PROGRAMME^source.getFileName(), code);  
end
}

ENTITES -> #gen ;
#gen {
do
    ENTITES^code := "";
end
}


ENTITES -> #tds ENTITE #tds2 ENTITES #gen;
#gen {
do
    ENTITES^code := ENTITE^code + ENTITES1^code;
end
}    
#tds {
do
    -- transmission de la tds parente
    ENTITE^tds := ENTITES^tds;
end
}
#tds2 {
do
    -- transmission de la tds parente après ajout de l'entite
    ENTITES1^tds := ENTITES^tds;
end
}


-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds #gen;
#tds {
local
    i : INFO ;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    if i /= null then
       error(B_01, identc^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      ENTITE^tds.inserer(identc^txt,  i);
    end
end
}
#gen {
do
    ENTITE^code := "";        
end
}


-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
ENTITE ->  TYPE ident #tds #nomFonction DECL #gen;
#tds {
local
    i : INFO ;
do
    i := ENTITE^tds.chercherGlobalement(ident^txt);
    if i /= null then
       error(B_02, ident^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      ENTITE^tds.inserer(ident^txt,  i);
    end
    -- transmission tds
    DECL^tds := ENTITE^tds;
end
}
#nomFonction {
do
    DECL^identDecl := ident^txt;
end
}
#gen {
do 
    ENTITE^code := "";
end
}


-- Variable
DECL -> pv ;

-- déclaration d'une fonction
DECL ->#tds FONCTION ;
#tds {
do
    FONCTION^tds := DECL^tds;
end
}

-- Fonction
FONCTION -> #tailleRetour paro #tds PARFS parf BLOC #gen;
global
    tdsParam : TDS;
    tam : IMachine;
    tailleRetour : INTEGER;
#tailleRetour {
 local
    i : INFO ;
    it : INFOTYPE;
    t : DTYPE;
 do
    -- rechercher l'ident   
    i := FONCTION^tds.chercherGlobalement(FONCTION^identDecl);
    if i = nil then
      error(B_05, FONCTION^identDecl);
    else
        tailleRetour := i.getTaille();
    end
end
}    
#tds {
do
    tdsParam := new TDS(FONCTION^tds);
    PARFS^tds := tdsParam; 
    BLOC^tds := new TDS(tdsParam);
    BLOC^hdep := 3;
end
}
#gen{
local
  cp : STRING ; -- code sous la forme d'une fonction
do
    tam := FONCTION^machine;
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    cp := tam.genFonction(FONCTION^identDecl, tdsParam.getTailleParam(), tailleRetour, BLOC^code);
end
}

-- parametres de fonctions
PARFS ->  ;
-- Done


-- 
-- multi paramètres
PARFS -> #tds PARF PARFSX ;
global
    tds:TDS;
#tds {
do
    tds := new TDS(PARFS^tds);
    PARF^tds := tds;
    PARFSX^tds := tds;
end
}


PARFSX ->  ;
-- Done


PARFSX -> #tds  virg PARF PARFSX ;
global
    tds:TDS;
#tds {
do
--PROBLEME: merge les 2 tds pour n'avoir qu'une seule tds param
    tds := new TDS(PARFSX^tds);
    PARF^tds := tds;
    PARFSX1^tds := tds;
end
}

-- type
PARF -> TYPE ident #tds;
#tds {
local
    i : INFO ;
do
    i := PARF^tds.chercherGlobalement(ident^txt);
    if i /= null then
       error(B_02, ident^txt);
    else    
      -- creer un type
      i := new INFOTYPE(TYPE^type);
      PARF^tds.inserer(ident^txt,  i);
    end
end
}

-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE PTRS #type;
#type {
do
    if PTRS^type = nil then
        TYPE^type := STYPE^type;
    else
        TYPE^type := new POINTEUR(PTRS^type) ;
    end    
end
}

-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type {
do
    PTRS^type := nil;
end
}

-- variable qualifiee 
PTRS -> mult PTRS #type;
#type {
do
    PTRS^type := new POINTEUR(PTRS1^type);
end
}

-- types de base
STYPE-> void #type ;
#type {
do
    STYPE^type := new DTYPE("void");
end
}

STYPE-> int #type;
#type {
do
    STYPE^type := new DTYPE("int");
end
}

STYPE-> char #type;
#type {
do
    STYPE^type := new DTYPE("char");
end
}

-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
do
    STYPE^type := new DTYPE(identc^txt);
end
}

-------------  
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type;
global 
 lc : LCHAMPS ;
#ch {
do
  lc := new LCHAMPS();
  CHAMPS^champs := lc;
  CHAMPS^hdep := 0;
end
}
#type {
 do
   STYPE^type := new STRUCT(lc);
 end
}


CHAMPS -> ;
-- Done

-- un nom de champ commence par une minuscule
CHAMPS -> #champ CHAMP CHAMPS ;
#champ {
do
    CHAMP^champs := CHAMPS1^champs;
end
}


CHAMP -> TYPE ident pv #champ;
#champ {
 local
  c : CHAMP ;
 do
  c := CHAMP^champs.chercher(ident^txt);
    if c /= null then
       error(B_00, ident^txt);
    else    
      c := new CHAMP(ident^txt, TYPE^type, CHAMPS^hadr);
     CHAMP^champs.inserer(c);
    end
 end
}


-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS acf #gen;
global        -- globale aux actions de cette regle
  t : TDS;    -- pour voir la TDS du bloc
#tds {
do
   t :=  new TDS(BLOC^tds);
   INSTS^tds := t;
end
}
#gen {
do
   write "; tds:\n" + t;
   write "; taille des locales = " + (INSTS^dep - BLOC^hdep)+ "\n";
   BLOC^code := INSTS^code + BLOC^tam.genFree(INSTS^dep - BLOC^hdep);
end
}

-- instructions --
INSTS ->  #gen ;
#gen {
do
  INSTS^dep := INSTS^hdep ;
  INSTS^code := "";
end
}

INSTS ->  INST #dep INSTS #gen ;
#dep {
do
  INSTS1^hdep := INST^dep;
end
}
#gen {
do
  INSTS^dep := INSTS1^dep;
  INSTS^code := INST^code + INSTS1^code;
end
}

--TODO prendre en compte AFFX
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident AFFX pv #gen;
#gen {
local
    i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(B_00, ident^txt);
    else    
      -- creer un type
     i := new INFOTYPE(TYPE^type);
     call INST^tds.inserer(ident^txt,  i);
     INST^dep := INST^hdep ;
     INST^code := "";
    end
end
}

-- instruction expression (affectation et appel de procedure)
INST -> E pv ;


-- bloc d'instructions
INST ->  BLOC  ;


--TODO prendre en compte SIX
-- conditionnelle
INST ->  #tds si paro E #type parf BLOC SIX #gen;
#gen {
do
    INST^dep := INST^hdep;
    INST^code := INST^tam.genIf(E^code, BLOC^code, BLOC1^code) ;
end
}
#type {
do
   if ~E^type.compareTo(new DTYPE("bool", 1)) then
      error(B_04, E^type);
   end
end
}
#tds {
do
    BLOC^tds := INST
end
}


SIX ->    sinon BLOC ;


SIX -> ;


-- retour de fonction
INST ->  retour  E pv #type;
#type {
--controle de type retour-annoncé a l'init fonction
do
    
end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

E ->   A #type AFFX ;
#type {
do
    AFFX^type := A^type;
end
}

-- affectation
AFFX -> affect  A  #type;
#type {
-- controle de type
do
    if ~A^type.compareTo(AFFX^type) then
        error(B_10, A^type.getNom());
    end
end
}

AFFX -> ;
-- relation
A ->   R AX  ;
AX -> OPREL R;
AX ->  ;

-- operateurs relationnels
OPREL -> inf #type;
#type {
-- controle de type
do
    if ~OPREL^type.compareTo("int") then
        error(B_10, OPREL^type.getNom());
    end
end
}

OPREL -> sup #type;
#type {
-- controle de type
do
    if ~OPREL^type.compareTo("int") then
        error(B_10, OPREL^type.getNom());
    end
end
}
OPREL -> infeg #type;
#type {
-- controle de type
do
    if ~OPREL^type.compareTo("int") then
        error(B_10, OPREL^type.getNom());
    end
end
}

OPREL -> supeg #type;
#type {
-- controle de type
do
    if ~OPUN^type.compareTo("int") then
        error(B_10, OPUN^type.getNom());
    end
end
}

OPREL -> eg #type;
#type {
-- controle de type
do
    if ~OPREL^type.compareTo("int") then
        error(B_10, OPREL^type.getNom());
    end
end
}

OPREL -> neg #type;
#type {
-- controle de type
do
    if ~OPREL^type.compareTo("int") then
        error(B_10, OPREL^type.getNom());
    end
end
}


R ->  T  RX ;
-- additions ...
RX ->   OPADD  T RX  ;
RX -> ;
-- operateurs additifs
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
-- multiplication, ...
T ->  F  TX  ;
TX ->   OPMUL  F TX  ;
TX ->  ;
-- operateurs multiplicatifs
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;

-- expressions de base

-- Constante entiere --
F -> entier  #gen ;
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^tam.genCst(entier^txt);
    F^adresse := -1;
end
}

-- Constante chaine
F -> chaine #gen;
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^tam.genChaine(chaine^txt);
    F^adresse := -1;
end
}


-- Constante caractere
F -> caractere #gen;
#gen {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := F^tam.genCaractere(caractere^txt);
    F^adresse := -1;
end
}


-- expression unaire
F ->  OPUN  F #type #gen ;
#type {
do
    F^type := F1^type;
end
}
#gen {
do
    F^code := F1^code + OPUN^code;
end
}

-- operateurs unaires
OPUN -> plus #type;
#type {
-- attribut de classe
do

end
}

OPUN -> moins #type;
#type {
do
-- attribut d'instance  
end
}

OPUN -> non #type;
#type {
do
    if ~OPUN^type.compareTo("bool") then
        error(B_10, OPUN^type.getNom());
    end
end
}

-- pointeur NULL
F -> null #type ;
#type {
do
    F^type := new POINTEUR(F^type);
end
}


-- expression parenthesee
F ->  paro E parf FX ;

F ->  paro TYPE parf  F ;
F -> mult F ;
F -> ident FX ;
FX -> ;

-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
