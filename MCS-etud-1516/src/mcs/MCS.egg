-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,OPUN,OPMUL,OPREL,OPADD,
         BASE, DEFS, DEF;--,ASMINST,ASM,ASMINSTS;
              

-- MODE
-- acces variable ou non (ASM)
--syn mode    : BOOLEAN for MODD;
syn mode    : STRING for MODE;

-- IDENT
inh ident   : STRING for DECL, FONCTION,FX,IDC,BASE;
syn sident  : STRING for PARF, CHAMP,IDC,HERITAGE,DEF;

-- TYPE
syn type    : DTYPE for F,FX, TYPE,PARF,E, STYPE,CHAMP,PTRS, AFFX, A,AX, R,RX,T,TX,OPADD, OPMUL,OPUN,OPREL;
inh htype   : DTYPE for  DECL,FONCTION,PTRS,BLOC,SIX,INSTS,INST,AFFX,AX,FX,RX,TX;

-- INFO
inh hdep : INTEGER for AFFX,FX;
syn sdep : INTEGER for E,A,R,T,F,FX;
syn sinfo : INFO for DEF,DECL,FONCTION;

-- TDS
inh tds_asm : TDS for ASM;--, ASMINST, ASMINSTS;
inh tds     : TDS     for    BLOC, ENTITE,ENTITES,CHAMP,CHAMPS, INSTS,TYPE,STYPE, INST, FONCTION, DECL, PARFS, PARF, PARFSX, 
                            SIX ,E,ES,ESX,F,FX,T,TX,R,RX,A,AFFX,AX,DEFS,DEF,HERITAGE,BASE;
syn stds    : TDS for PARFS,PARFSX,ES,ESX,ENTITES,DEFS;      


-- INST
inh hest_decl : BOOLEAN for AFFX;                                              
                            
-- GC                            
syn code    : STRING for ENTITE , ENTITES,DECL,FONCTION, F,FX, BLOC,SIX, INSTS, INST, E, AFFX,OPUN,OPMUL,OPREL,OPADD,T,TX,A,AX,R,RX,DEFS,DEF,BASE;
inh hcode   : STRING for AFFX,FX;
syn code_asm : STRING for ASM;--,ASMINST,ASMINSTS;

inh hchamps : LCHAMPS for CHAMPS, CHAMP;
syn champs : LCHAMPS for CHAMPS;

-- ADRESSE
syn code_est_adresse : BOOLEAN for  AFFX,F, A,AX,R,RX,T,TX,E ;
inh hcode_est_adresse : BOOLEAN for AFFX,AX,RX,TX ,F;

-- FONCTION
inh hbloc_est_fonction : BOOLEAN for BLOC;

-- ACCES
syn acces : STRING for ACCES;

-- CHAMPS CLASSE
inh hchampsclasse : LCHAMPS for DEFS;
syn schampsclasse : LCHAMPS for DEFS;

-- HERITAGE
syn aHeritage : BOOLEAN for HERITAGE;


sugar malloc is "malloc";
--term identASM is "[A-Z]*";
--term allident is "[_0-9A-Za-z]*";
--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
sugar ref is "ref" ;
sugar out is "out";
sugar namespace is "namespace";
sugar using is "using";
sugar class is "class";
sugar public is "public" ;
sugar private is "private";
sugar dpts is "\:";
sugar bool is "bool";
sugar true is "true";
sugar false is "false";
sugar this is "this";
sugar new is "new" ;
sugar null2 is "null";
sugar base is "base" ; 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init #tds ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do

   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#tds {
do
    --init de la TDS ( sans parente )
    ENTITES^tds := new TDS(nil);
end
}
-- ecrit le code dans un fichier
global
    code : String;
#gen {
local
do
   -- on suppose la methode "int main()" existante, et sans parametres
   code := "\n" + ENTITES^code + machine.genCall("main")+ machine.genFin();
   -- generation du code de fin du programme
   machine.writeCode(PROGRAMME^source.getFileName(), code);
end
}

------------------------------------------------------------------------
ENTITES -> #gen ;
#gen {
do
    ENTITES^stds := ENTITES^tds;

    ENTITES^code := "";
end
}

------------------------------------------------------------------------
ENTITES -> #init  ENTITE ENTITES #gen;
#init {
do
    -- reset currentDep
    ENTITES^machine.resetCurrentDep();
end
}
#gen {
do  
    ENTITES^stds := ENTITES1^stds;

    ENTITES^code := ENTITE^code + ENTITES1^code;
end
}    

------------------------------------------------------------------------
-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds #gen;
#tds {
local 
    i : INFO;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    if i != nil then
        error(type_declared, identc^txt, ENTITE^tds);
    else    
        ENTITE^tds.inserer(identc^txt, new INFOTYPE(TYPE^type));
    end    
end
}
#gen {
do
    ENTITE^code := "";        
end
}

------------------------------------------------------------------------
-- definition d'une variable globale ou d'une fonction (commence par une minuscule)
ENTITE ->  TYPE ident #decl DECL #gen;
#decl {
do
    DECL^ident := ident^txt;
    DECL^htype := TYPE^type;
end
}
#gen {
do 
    ENTITE^code := DECL^code;
end
}

-- Variable
DECL -> pv #tds #gen;
global
    i : INFO;
    type : DTYPE;
    iv : INFOVAR;
#tds {
do
    i := DECL^tds.chercherGlobalement(DECL^ident);
    if i /= nil then
        error(var_declared, DECL^ident);
    else
        type := DECL^htype;
        iv := new INFOVAR(type, DECL^machine.getCurrentDep());
        
        -- insertion
        DECL^tds.inserer(DECL^ident,  iv);
        DECL^machine.addCurrentDep(type.getTaille());
        
        -- remontee de l'info pour la def
        DECL^sinfo := iv;
    end    
end
}
#gen {
do
    -- si pointeur ou struct
    match type 
    with POINTEUR then 
        DECL^code := DECL^machine.genMalloc(type.getTaille());
    with STRUCT then
        DECL^code := DECL^machine.genMalloc(type.getTaille());
    else
        DECL^code := DECL^machine.genVar(type.getTaille());
    end
end
}

------------------------------------------------------------------------
-- declaration d'une fonction
DECL -> #ident FONCTION #gen #sinfo;
#ident {
do
    FONCTION^ident := DECL^ident;
    FONCTION^htype := DECL^htype;
end
}
#gen {
do
    DECL^code := FONCTION^code;
end
}
#sinfo{
do
    DECL^sinfo := FONCTION^sinfo;
end
}

------------------------------------------------------------------------
-- Fonction
FONCTION -> paro #tds PARFS #stds parf BLOC #gen;
global
    i : INFOFONC;
    tdsParam : TDS;
#tds {
do  
    PARFS^tds := new TDS(FONCTION^tds);
end
}     
#stds {
do
    BLOC^hbloc_est_fonction := true;

    tdsParam := PARFS^stds;
    BLOC^tds := new TDS(tdsParam);
    
   -- debut de BLOC : currentDep reset
   FONCTION^machine.resetCurrentDep();
   -- ajout de 3 pour les variables utilisees par TAM
   FONCTION^machine.addCurrentDep(3);
    
end
}
#gen{
local
    typeRetour : DTYPE;
do

    -- TDS
    i := new INFOFONC(FONCTION^htype, tdsParam);
    
    -- remontee de l'info pour la def
    FONCTION^sinfo := i;
    
    FONCTION^tds.inserer(FONCTION^ident, i);
    typeRetour :=i.getType();
    
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    FONCTION^code := FONCTION^machine.genFonction(FONCTION^ident, tdsParam.getTailleParams(), typeRetour.getTaille(), BLOC^code);
end
}

------------------------------------------------------------------------
-- parametres de fonctions
PARFS ->  #tds;
#tds{
do
    PARFS^stds := PARFS^tds;
end
}


------------------------------------------------------------------------
-- multi parametres
PARFS -> PARF #tds PARFSX #stds;
global
    tds:TDS;
#tds {
do  
    PARFS^machine.resetCurrentDep();
    PARFS^machine.addCurrentDep(-PARF^type.getTaille());  
    tds := PARFS^tds;  
    tds.inserer(PARF^sident, new INFOVAR(PARF^type, PARFS^machine.getCurrentDep()));
    
    PARFSX^tds := tds;
end
}
#stds {
do
    PARFS^stds := PARFSX^stds; 
end
}

------------------------------------------------------------------------
-- fin parametre
PARFSX -> #stds ;
#stds {
do
    PARFSX^stds := PARFSX^tds;
end
}

-- multi parametres
PARFSX -> virg PARF #tds PARFSX #stds;
#tds {
local
    tds : TDS;
do 

    -- transmission des tds;
    tds := PARFSX^tds;
    -- deplacement avant ajout de var
    PARFSX^machine.addCurrentDep(-PARF^type.getTaille());
    tds.inserer(PARF^sident, new INFOVAR(PARF^type, PARFSX^machine.getCurrentDep()));
        
    PARFSX1^tds := tds;
end
}
#stds {
do
    PARFSX^stds := PARFSX1^stds;
end
}

------------------------------------------------------------------------
-- parametre fonction
PARF -> TYPE ident #tds;
#tds {
do
    PARF^type := TYPE^type;
    PARF^sident := ident^txt;
end
}

------------------------------------------------------------------------
-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE #htype PTRS #type;
#htype {
do
    PTRS^htype := STYPE^type; 
end
}
#type {
do
    TYPE^type := PTRS^type;
end
}

------------------------------------------------------------------------
-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type {
do
    PTRS^type := PTRS^htype;
end
}

------------------------------------------------------------------------
-- variable qualifiee 
PTRS -> mult #htype PTRS #type;
#htype {
do
    PTRS1^htype := new POINTEUR(PTRS^htype);
end
}
#type {
do
    PTRS^type := PTRS1^type;
end
}

------------------------------------------------------------------------
-- types de base
STYPE-> void #type ;
#type {
do
    STYPE^type := new DTYPEImpl("void",0);
end
}

------------------------------------------------------------------------
STYPE-> int #type;
#type {
do
    STYPE^type := new DTYPEImpl("int",1);
end
}

------------------------------------------------------------------------
STYPE-> char #type;
#type {
do
    STYPE^type := new DTYPEImpl("char",1);
end
}

------------------------------------------------------------------------
-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
local
    i : INFO ;
do
    i := STYPE^tds.chercherGlobalement(identc^txt);
    if i = nil then
        error(type_undefined, identc^txt);
    else    
        match i with INFOTYPE then
            STYPE^type := i.getType();
        else
            error(not_infotype, identc^txt);    
        end
    end
end
}

------------------------------------------------------------------------ 
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type;
#ch {
do
  CHAMPS^hchamps := new LCHAMPS();
end
}
#type {
 do
   STYPE^type := new STRUCT(CHAMPS^champs);
 end
}

------------------------------------------------------------------------
CHAMPS -> #ch;
#ch {
do
    CHAMPS^champs := CHAMPS^hchamps;
end
}

------------------------------------------------------------------------
-- un nom de champ commence par une minuscule
CHAMPS ->  CHAMP #hch CHAMPS #ch;
#hch {
    local
    c : CHAMP ;
do
    -- insertion
    c := CHAMPS^hchamps.chercherChamp(CHAMP^sident);
    if c /= nil then
        error(champ_declared, CHAMP^sident, CHAMPS^hchamps);
    else    
        CHAMP^hchamps.inserer(new CHAMP(CHAMP^sident, CHAMP^type, CHAMPS^hchamps.getCurrentDep()));
    end  
    
    -- transmission
    CHAMPS1^hchamps := CHAMPS^hchamps;
end
}
#ch {
do
    CHAMPS^champs := CHAMPS1^champs;
end
}

------------------------------------------------------------------------
CHAMP -> TYPE ident pv #champ;
#champ {
do
    CHAMP^type := TYPE^type;
    CHAMP^sident := ident^txt;
end
}

------------------------------------------------------------------------
-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS acf #gen;
#tds {
do

   INSTS^tds := BLOC^tds;
   
end
}
#gen {
do  
    BLOC^code := INSTS^code;
end
}

------------------------------------------------------------------------
-- instructions --
INSTS ->  #gen ;
#gen {
do
  INSTS^code := "";
end
}

------------------------------------------------------------------------
INSTS ->  INST INSTS #gen ;
#gen {
do
  INSTS^code := INST^code + INSTS1^code;
end
}

------------------------------------------------------------------------
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident #htype AFFX pv #tds #type #gen ;
#htype {
local
    i : INFO;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(var_declared, ident^txt);
    else  
        -- transmission de l'info
        AFFX^hdep := INST^machine.getCurrentDep();
    end
    

    -- transmission de type
    AFFX^htype := TYPE^type;
    -- transmission de l adresse
    AFFX^hcode_est_adresse := false;
    AFFX^hcode := "";
    
    AFFX^hest_decl := true;
end
}
#tds {
local
    i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(var_declared, ident^txt);
    else  
        i := new INFOVAR(TYPE^type, INST^machine.getCurrentDep());
        INST^tds.inserer(ident^txt, i);
        -- deplacement de currentDep
        INST^machine.addCurrentDep(TYPE^type.getTaille());
    end
end
}
#type {
do
    -- controle de type
   if ~TYPE^type.compareTo(AFFX^type) then
      error(affect_notCompatible, TYPE^type.getNom(), AFFX^type.getNom());
   end
   
end
}
#gen {
do
    INST^code := AFFX^code;
end
}

------------------------------------------------------------------------
-- instruction expression (affectation et appel de procedure)
INST -> E pv #gen;
#gen {
do
    INST^code := E^code;
end
}

------------------------------------------------------------------------
-- bloc d'instructions
INST ->#bloc BLOC  #code;
#bloc {
do
    BLOC^hbloc_est_fonction := false;
end
}
#code {
do
    INST^code := BLOC^code;        
end
}


------------------------------------------------------------------------
-- conditionnelle
INST ->  si paro E #type parf BLOC SIX #gen;
#type {
do
   if ~E^type.compareTo(new DTYPEImpl("bool", 1)) then
      error(not_bool, E^type.getNom());
   end
   
   BLOC^hbloc_est_fonction := false;
end
}
#gen {
do
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;
end
}

------------------------------------------------------------------------
-- bloc sinon 
SIX ->    sinon #dep BLOC #gen;
#dep {
do
   BLOC^hbloc_est_fonction := false;
end
}
#gen {
do
    SIX^code := BLOC^code;
end
}

------------------------------------------------------------------------
-- pas de bloc sinon
SIX -> #gen;
#gen{
do
    SIX^code := "";
end
}

------------------------------------------------------------------------
-- retour de fonction
INST ->  retour E pv #type #gen;
#type {
do
    -- controle de type de retour
   if ~INST^htype.compareTo(E^type) then
      error(returnType_notCompatible, INST^htype, E^type);
   end    
    
end
}
#gen {
do
    INST^code := E^code;
end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

------------------------------------------------------------------------
E -> A #type AFFX #gen;
#type {
do  
    AFFX^hdep := A^sdep;
    E^sdep := A^sdep;
  
    AFFX^hcode_est_adresse := A^code_est_adresse;
    
    E^type := A^type;
    -- type pour permettre le controle d'erreur au moment de l'affectation
    AFFX^htype := A^type; 
    
    AFFX^hcode := A^code;
    
    
    AFFX^hest_decl := false;
end
}
#gen {
do
    E^code_est_adresse := AFFX^code_est_adresse;
    
    E^code := AFFX^code;  
end
}

------------------------------------------------------------------------
-- affectation
AFFX -> affect A  #type #gen;
#type {
-- controle de type
do
    AFFX^code_est_adresse := false;    
    
    if ~AFFX^htype.compareTo(A^type) then
        error(affect_notCompatible, AFFX^htype.getNom() ,A^type.getNom());
    else
        -- remonter le type pour la declaration avec affectation
        AFFX^type := A^type;    
    end
end
}
#gen {
local 
  codeWrite : STRING;
do  
    
    if AFFX^hcode_est_adresse then
        codeWrite := AFFX^hcode + AFFX^machine.genWriteIndirectMem(AFFX^htype.getTaille());
    else
        codeWrite := AFFX^machine.genWriteMem(AFFX^hdep, AFFX^htype.getTaille());
    end    

    -- si declaration + affectation, on laisse directement le code en sommet de pile
    if AFFX^hest_decl then
        AFFX^code := A^code ;
    else      
        AFFX^code := A^code + codeWrite;
    end
            

end  
}

------------------------------------------------------------------------
AFFX ->#type #gen;
#type {
do
    AFFX^code_est_adresse := AFFX^hcode_est_adresse;
    
    AFFX^type := AFFX^htype;
end
}
#gen {
do
    if AFFX^hest_decl then
        AFFX^code := AFFX^machine.genVar(AFFX^htype.getTaille());    
    else
        AFFX^code := AFFX^hcode;
    end    
end
}

------------------------------------------------------------------------
-- relation
A -> R #type AX #gen;
#type{
do 
    -- remontee infovar
    A^sdep := R^sdep;
    
    -- transmission du type de R pour le controle de type
    AX^htype := R^type;
    
    AX^hcode_est_adresse := R^code_est_adresse;
end
}
#gen {
do
    -- on remonte le type
    A^type := AX^type;
    
    -- generation du code qui renvoie la valeur correspond a la relation
    A^code := R^code + AX^code;

    A^code_est_adresse := AX^code_est_adresse;   
end
}

------------------------------------------------------------------------
AX -> OPREL R #type #gen;
#type {
do
    -- controle de type
    if ~AX^htype.compareOpBin(OPREL^type, R^type) then
        error(typeError_opBin, AX^htype.getNom(), OPREL^type.getNom(), R^type.getNom());
    else
    -- on remonte le type
        AX^type := new DTYPEImpl("bool",1);         
    end 
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur relationnel
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    AX^code := R^code + OPREL^code;     
    -- membre de droite lors de la relation -> ce n est pas une adresse
    AX^code_est_adresse := false;
end
}


------------------------------------------------------------------------
AX ->  #type #gen;
#type {
do
    AX^type := AX^htype;

    AX^code_est_adresse := AX^hcode_est_adresse;
end
}
#gen {
do
    AX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs relationnels
OPREL -> inf #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELINF",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILss");
end
}

------------------------------------------------------------------------
OPREL -> sup #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELSUP",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGtr");    
end
}

------------------------------------------------------------------------
OPREL -> infeg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELINFEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILeq");    
end
}

------------------------------------------------------------------------
OPREL -> supeg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELSUPEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGeq");    
end
}

------------------------------------------------------------------------
OPREL -> eg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IEq");    
end
}

------------------------------------------------------------------------
OPREL -> neg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELNEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("INeq");    
end
}

------------------------------------------------------------------------
-- additions multiples
R -> T #type RX #gen;
#type{
do
    -- remontee infovar
    R^sdep := T^sdep;
    
    -- transmission du type de R pour le controle de type
    RX^htype := T^type;
    -- on remonte le type
    R^type := T^type;
    
    RX^hcode_est_adresse := T^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    R^code := T^code + RX^code;

    R^code_est_adresse := RX^code_est_adresse;  
end
}

------------------------------------------------------------------------
-- additions ...
RX ->   OPADD  T RX  #type #gen;
#type {
do
    -- controle de type
    if ~RX^htype.compareOpBin(OPADD^type, T^type) then
        error(typeError_opBin, RX^htype.getNom(), OPADD^type.getNom(), T^type.getNom());    
    elseif ~RX^htype.compareOpBin(OPADD^type, RX1^type) then
        error(typeError_opBin, RX^htype.getNom(), OPADD^type.getNom(), RX1^type.getNom());
    else
    -- on remonte le type
        RX^type := T^type;         
    end 
end
}
#gen {
do
    -- opadd donc ce n est plus une adresse
    RX^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur add
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    RX^code := T^code + RX1^code + OPADD^code;         
end
}


------------------------------------------------------------------------
RX -> #type;
#type {
do
    RX^type := RX^htype;
    -- adresse
    RX^code_est_adresse := RX^hcode_est_adresse;
    -- GC
    RX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs additifs
OPADD -> plus #type;
#type {
do  
    OPADD^type := new DTYPEImpl("OPADDPLUS",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("IAdd");     
end
}

------------------------------------------------------------------------
OPADD -> moins #type;
#type {
do
    OPADD^type := new DTYPEImpl("OPADDMOINS",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("ISub");     
end
}

------------------------------------------------------------------------
OPADD -> ou #type;
#type {
do
    OPADD^type := new DTYPEImpl("OPADDOU",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("BOr");     
end
}

------------------------------------------------------------------------
-- multiplication, ...
T -> #haddr F #type TX #gen ;
#haddr {
do
    F^hcode_est_adresse := false;
end
}
#type{
do
    -- remontee infovar
    T^sdep := F^sdep;
    
    -- transmission du type de R pour le controle de type
    TX^htype := F^type;
    -- on remonte le type
    T^type := F^type;
    

    TX^hcode_est_adresse := F^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    T^code := F^code + TX^code;

    T^code_est_adresse := TX^code_est_adresse;
end
}

------------------------------------------------------------------------
TX -> OPMUL F TX  #type #gen;
#type {
do
    -- controle de type
    if ~TX^htype.compareOpBin(OPMUL^type, F^type) then
        error(typeError_opBin, TX^htype.getNom(), OPMUL^type, F^type);    
    elseif ~TX^htype.compareOpBin(OPMUL^type, TX1^type) then
        error(typeError_opBin, TX^htype.getNom(), OPMUL^type, TX1^type);
    else
    -- on remonte le type
        TX^type := F^type;     
    end
    
    TX^code_est_adresse := false; 
  
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur multiple
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    TX^code := F^code + TX1^code + OPMUL^code;    
end
}

------------------------------------------------------------------------
TX -> #type ;
#type {
do
    TX^type := TX^htype;
    TX^code := "";
    
    TX^code_est_adresse := TX^hcode_est_adresse;
end
}

------------------------------------------------------------------------
-- operateurs multiplicatifs
OPMUL -> mult #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULMULT",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMul");    
end
}

------------------------------------------------------------------------
OPMUL -> div #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULDIV",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IDiv");      
end
}

------------------------------------------------------------------------
OPMUL -> mod #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULMOD",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMod");      
end
}

------------------------------------------------------------------------
OPMUL -> et #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULET",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("BAnd");      
end
}

-- expressions de base

------------------------------------------------------------------------
-- Constante entiere --
F -> entier #gen ;
#gen {
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("int", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(entier^txt);
end
}

------------------------------------------------------------------------
-- Constante chaine
F -> chaine #gen;
#gen {
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("chaine", 3);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(chaine^txt);
end
}

------------------------------------------------------------------------
-- Constante caractere
F -> caractere #gen;
#gen {
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("char", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(caractere^txt);
end
}

------------------------------------------------------------------------
-- expression unaire
F -> OPUN  F #type #gen;
#type {
do
    -- pas une var
    F^sdep := -1;
    
    -- controle de type
    if ~F1^type.compareOpUn(OPUN^type) then
        error(typeError_opUn, F1^type.getNom(), OPUN^type.getNom());
    else
    -- on remonte le type
        F^type := F1^type;         
    end 
  
end
}
#gen {
do
    F^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur unaire
    -- on empile d abord la valeur puis on fait un SUBR op
    F^code := F1^code + OPUN^code;
end
}

------------------------------------------------------------------------
-- operateurs unaires
OPUN -> plus #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNPLUS",1);
    -- SUBR op
    OPUN^code := "";
end
}

------------------------------------------------------------------------
OPUN -> moins #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNMOINS",1);
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("Ineg");
end
}

------------------------------------------------------------------------
OPUN -> non #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNNON",1);
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("BNeg");    
end
}

------------------------------------------------------------------------
-- pointeur NULL
F -> null #type ;
#type {  
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("PNULL", 1);
    F^code_est_adresse := false;
    F^code := "";
end
}

------------------------------------------------------------------------
-- expression parenthesee
F ->  paro E parf #addr FX #type #gen;
#addr {
do
    -- remontee infovar
    F^sdep := E^sdep;
    
    FX^hdep := E^sdep;

    FX^ident := "";

    F^code_est_adresse := E^code_est_adresse;
    -- type de FX est le type de l expression de gauche
    FX^htype := E^type;
    
     FX^hcode := E^code; 
end
}
#type {
do
    -- controle de type
    if ~E^type.compareTo(FX^type) then
        error(castError, E^type.getNom(), FX^type.getNom());
    else
    -- on remonte le type
        F^type := E^type;   
            
    end 
  
end
}
#gen {
do
    
    -- GC
    F^code := FX^code;
end
}


------------------------------------------------------------------------
-- cast
F ->  paro TYPE parf  F  #type #gen;
#type {
do
 
    -- si MAlloc pas de probleme
    if F1^type.compareTo(new DTYPEImpl("void",0)) then
        F^type := TYPE^type;
    else    
    -- sinon verifier la castabilite
        if ~F1^type.isCastableAs(TYPE^type) then
            error(not_castable_as, F1^type.getNom(), TYPE^type.getNom());
        else
            F^type := TYPE^type;
            
            -- remontee infovar
            F^sdep := F1^sdep;
        end
    end
end
}
#gen {
do
    -- remontee des infos
    F^code := F1^code;
    F^code_est_adresse := F1^code_est_adresse;
end
}

------------------------------------------------------------------------
-- allocation memoire d un pointeur
F -> malloc paro E parf #gen;
#gen {
do
    -- remontee infovar
    F^sdep := E^sdep;

    if ~E^type.compareTo(new DTYPEImpl("int",1)) then
        error(malloc_need_int, E^type.getNom());
    else
        F^type := new DTYPEImpl("void",0);
        F^code_est_adresse := false;
        
        F^code := E^code + F^machine.genOp("MAlloc");
    end
     
end
}

------------------------------------------------------------------------
F -> mult #ptr F #type #addr;
#ptr {
do
    F1^hcode_est_adresse := true;
end
}
#type {
local
    p : POINTEUR;
do

    -- remontee infovar
    F^sdep := F1^sdep;

    match F1^type 
    with POINTEUR then
        p := F1^type;
        F^type := p.getType();      
        F^code_est_adresse := true;
    else
        error(not_pointeur, F1^type.getNom());
    end        
end
}
#addr {
do
    -- code acces a un pointeur
    F^code := F1^code ;
end
}

------------------------------------------------------------------------
F -> ident #htype FX #gen;
global 
  iv : INFOVAR ;
  infofonc : INFOFONC;
  t : DTYPE;
#htype {
local
    i:INFO;
    i2:INFO;
    code : STRING;
do  

    -- ident pour l'appel de fonction
    FX^ident := ident^txt;

    i := F^tds.chercherGlobalement(ident^txt);
    
    if i = null then
        error(var_not_found, ident^txt, "null");
    else
        match i 
        with INFOVAR then
            iv := i;
            t := iv.getType();
            
            FX^hdep := iv.getDep();
            
            FX^htype := t;
            F^code_est_adresse := false;

            -- code de lecture de variable            
            if F^hcode_est_adresse then
                code := F^machine.genAdr(iv.getDep()) + F^machine.genReadIndirectMem(t.getTaille());
            else
                code := F^machine.genReadMem(iv.getDep() , iv.getTaille()); 
            end   
            
            FX^hcode := code;
        
        with INFOFONC then
            infofonc := i;  
            t := infofonc.getType();
            FX^htype := t;
            FX^hcode := "";
            F^code_est_adresse := false;
            code := "";
        else
            error(type_unknown, ident^txt, i.getType());
        end
        FX^htype := t;
    end 
end
}  
#gen{
do
    -- remontee infovar
    F^sdep := FX^sdep;

    F^type := FX^type;
    
    F^code := FX^code;    
end
}

------------------------------------------------------------------------
FX -> #gen;
#gen {
do
    FX^sdep := FX^hdep;

    FX^type := FX^htype;
   
    FX^code := FX^hcode;
end
}

------------------------------------------------------------------------
-- acces champ
FX ->   pt  ident #a FX #gen;
#a {
local
    t : DTYPE;
    p : POINTEUR;
    s : STRUCT ;
    c : CHAMP;
    lc : LCHAMPS;
    ct : DTYPE;
    code : STRING;
do
    
    code := "";
    match FX^htype 
    with POINTEUR then
        p := FX^htype;
        t := p.getType();
        match t with
        STRUCT then
            s := t;
            lc := s.getChamps();
            c := lc.chercherChamp(ident^txt);
            ct := c.getType();
            FX^sdep := c.getDep();
            if c = nil then
                error(champ_not_found, lc, ident^txt);
            else
                FX1^htype := new POINTEUR(c.getType());
                code := FX^hcode + FX^machine.genAdrField(c.getDep());
            end    
        else
            error(type_not_struct, FX^htype.getNom(), ident^txt);
        end        
    with STRUCT then
        s := FX^htype;
        lc := s.getChamps();
        c := lc.chercherChamp(ident^txt);
        ct := c.getType();
        if c = nil then
            error(champ_not_found, lc, ident^txt);
        else
            FX1^htype := c.getType();
            FX^sdep := c.getDep() + FX^hdep;
            code := FX^machine.genReadMem(c.getDep() + FX^hdep , ct.getTaille());
        end    
    else
        error(type_not_struct, FX^htype.getNom(), ident^txt);
    end
    FX1^hcode := code;    

end
}
#gen {
do
  FX^type := FX1^type;
  
  FX^code := FX1^code;
end
}


------------------------------------------------------------------------
-- acces champ pointeur
FX ->   arrow ident #htype FX #type #gen;
#htype {
local
    t : DTYPE;
    p : POINTEUR;
    s : STRUCT ;
    c : CHAMP;
    lc : LCHAMPS;
 
do
    match FX^htype with
    POINTEUR then
        p := FX^htype;
        t := p.getType();
            match t with
            STRUCT then
                s := t;
                lc := s.getChamps();
                c := lc.chercherChamp(ident^txt);
                if c = nil then
                    error(champ_not_found, lc, ident^txt);
                else
                    FX1^htype := c.getType();
                    FX^sdep := c.getDep() + FX^hdep;
                  FX1^hcode := FX^hcode + FX^machine.genAdrField(c.getDep());
                end    
            else
                error(type_not_struct, FX^htype.getNom(), ident^txt);
            end  
    else
        error(access_not_pointeur, ident^txt);
    end
end
}
#type {
do
    FX^type := FX1^type;    
end
}
#gen {
do
    FX^code := FX1^code;        
end
}

------------------------------------------------------------------------
-- appel de sous-programme
FX ->  #tds paro ES parf #htds FX #type #gen;
#tds {
do
    ES^tds := new TDS(nil);
end
}
#htds {
do
    FX1^tds := FX^tds;
end
}
#type {
do
    FX^type := FX1^type;
end
}   
#gen {
local
    i:INFO;
    infofonc : INFOFONC;
    tdsParam : TDS;
do
    FX^sdep := FX^hdep;

    -- appel du sous-programme a partir de l'étiquette
    
    i := FX^tds.chercherGlobalement(FX^ident);
    
    if i = null then
        error(var_not_found, FX^ident, "null");
    end

    match i     
    with INFOFONC then
        infofonc := i;
        tdsParam := infofonc.getParams();
        
        if ~ES^stds.compareTypeTo(tdsParam) then
            error(call_nomatch, FX^ident);  
        else
            FX^code := FX^machine.genArgs(ES^stds) + FX^machine.genCall(FX^ident) ;
        end
    else
        error(wrong_typeFonc, FX^ident, i.getType());
    end        
end
}

------------------------------------------------------------------------
-- arguments appel de sous-programme
ES -> #tds;
#tds {
do
    ES^stds := ES^tds;
end
}

------------------------------------------------------------------------
ES -> E #tds ESX #stds ;
global
    tds:TDS;
#tds {
do
    tds := ES^tds;
    -- TDSPARAM rappel : <"code", INFOTYPE>
    -- Rappel: la LinkedHashMap garantie l'ordre des get = l'ordre des put
    tds.inserer(E^code, new INFOTYPE(E^type));
    ESX^tds := tds;
end  
}
#stds {
do
    ES^stds := ESX^stds;
end
}

------------------------------------------------------------------------
ESX -> #stds ;
#stds {
do
    ESX^stds := ESX^tds;
end
}


------------------------------------------------------------------------
ESX -> virg E #tds ESX #stds;
#tds {
local
    tds : TDS;
do 
    tds := ESX^tds;
    -- appel : <"code", INFOTYPE>
    -- Rappel: la LinkedHashMap garantie l'ordre des get = l'ordre des put
    tds.inserer(E^code, new INFOTYPE(E^type));
    ESX1^tds := tds;
end
}
#stds {
do
    ESX^stds := ESX1^stds;
end
}

------------------------------------------------------------------------
------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := ENTITE^tds; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}
#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^code := ASM^code_asm;
end
}

------------------------------------------------------------------
-- Regles pour faire l ASM a la main 

--ASM -> aco ASMINSTS acf #gen;
--#gen {
--do
--    ASM^code_asm := ASMINSTS^code_asm;
--end
--}

--ASMINSTS -> ASMINST ASMINSTS #gen;
--#gen {
--do
--    ASMINSTS^code_asm := ASMINST^code_asm + ASMINSTS1^code_asm;
--end
--}

--ASMINST -> identASM MODD allident #gen;
--#gen {
--local
--    code : STRING;
--    i    : INFO;
--    iv   : INFOVAR;
--    t    : DTYPE;
--do
--    code := identASM^txt;
--    if MODD^mode then   
--        i := ASMINST^tds_asm.chercherGlobalement(allident^txt);
--        if i=nil then
--            error(var_not_found, allident^txt, nil);
--        else
--            match i with
--            INFOVAR then
--                iv := i;
--                t := iv.getType();
--                code := code + "(" + t.getTaille() + ")" + iv.getDep() + "[LB]";
--            else
--                error(not_infovar, allident^txt);
--            end 
--        end
--    else
--        code := code + allident^txt; 
--    end
--    ASMINST^code_asm := code;
--end
--}

--MODD -> mod #mode;
--#mode {
--do
--    MODD^mode := true; 
--end
--}

--MODD -> #mode;
--#mode {
--do
--    MODD^mode := false; 
--end
--}

----------------- CS extension ------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------
STYPE-> bool #type;
#type {
do
    STYPE^type := new DTYPEImpl("bool",1);
end
}

------------------------------------------------------------------------
---- definit un contenu d'un namespace
ENTITE -> namespace identc aco #contenu ENTITES acf #namespace #gen;
#contenu {
do
    -- init de la tds contenu de l INFONAMESPACE
    ENTITES^tds := new TDS(ENTITE^tds);
end
}
#namespace{
local 
    i : INFO;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    if i != nil then
        error(namespace_declared, identc^txt, ENTITE^tds);
    else    
        ENTITE^tds.inserer(identc^txt, new INFONAMESPACE(new DTYPEImpl("namespace",0) ,ENTITES^stds));
    end
end       
}
#gen{
do
    ENTITE^code := ENTITES^code;
end
}

------------------------------------------------------------------------
---- donne l acces au contenu du 'namespace'
ENTITE -> using identc #ident IDC pv #acces #gen;
#ident{
do
    IDC^ident := identc^txt;
end
}
#acces{
local
    name    : STRING;
    i       : INFO;
    ins     : INFONAMESPACE;
do
    i := ENTITE^tds.chercherNamespace(IDC^sident);
    if i = nil then
        error(namespace_unknown, IDC^sident, ENTITE^tds);
    else    
        match i with
        INFONAMESPACE then
            ins := i;
            -- changer la visibilite du namespace ( ajout a la liste )
            ENTITE^tds.addUsedNS(identc^txt, ins);
        else
            error(using_notNameSpace, identc^txt);
        end      
    end 
end
}
#gen {
do
    ENTITE^code := "";
end
}

------------------------------------------------------------------------
IDC -> #ident;
#ident {
do
    IDC^sident := IDC^ident;
end
}

------------------------------------------------------------------------
IDC -> pt identc #hident IDC #sident;
#hident{
do
    IDC1^ident := IDC^ident + "." + identc^txt;
end
}
#sident{
do
    IDC^sident := IDC1^sident;
end
}

------------------------------------------------------------------------
---- definition d'une classe (peut etre en dehors d'un namespace)
ENTITE -> ACCES class identc HERITAGE aco #htds DEFS acf #classe #gen;
#htds {
do
    -- tds du contenu de la classe (contient attributs et methodes)
    DEFS^tds := new TDS(ENTITE^tds);
    
    DEFS^hchampsclasse := new LCHAMPS();
end
}
#classe {
local
    i : INFO;
    ic : INFOCLASSE;
    ih: INFO;
    ihc : INFOCLASSE;
do
    -- si la classe n est pas deja definie dans ce namespace 
    i := ENTITE^tds.chercherLocalement(identc^txt);
    if i != nil then
        error(classe_defined, identc^txt, ENTITE^tds);
    else    
        -- si pas d heritage
        if ~HERITAGE^aHeritage then
            ic := new INFOCLASSE(DEFS^schampsclasse, ACCES^acces);
            -- insertion
            ENTITE^tds.inserer(identc^txt, ic); 
        else
            -- recherche de l heritage
            ih := ENTITE^tds.chercherClasse(HERITAGE^sident);
            if ih = nil then
                error(classe_undefined, HERITAGE^sident, ENTITE^tds);
            else 
                match ih with
                INFOCLASSE then   
                    ihc := ih;

                    -- definition de la classe
                    -- le type de la classe est un pointeur sur un struct et les champs sont les attributs et les fonctions
                    ic := new INFOCLASSE(DEFS^schampsclasse, ACCES^acces, ihc);
                    -- insertion
                    ENTITE^tds.inserer(identc^txt, ic); 
                else
                    error(not_infoclasse, HERITAGE^sident);
                end    
            end
        end 
    end   
end
}
#gen {
do
    -- table des variables pour le CALLI (liaison dynamique)   
    --ENTITE^code := ENTITE^machine.genTable(ic.getTV()) +  DEFS^code;    
    ENTITE^code := DEFS^code;
end
}

------------------------------------------------------------------------
---- acces 
ACCES -> public #acces;
#acces{
do
    ACCES^acces := "public";
end
}

------------------------------------------------------------------------
ACCES -> private #acces;
#acces{
do
    ACCES^acces := "private";
end
}

------------------------------------------------------------------------
ACCES -> #acces;
#acces{
do
    -- default
    ACCES^acces := "def";
end
}

------------------------------------------------------------------------
---- heritage
HERITAGE -> #sident;
#sident {
do
    HERITAGE^aHeritage := false;
    HERITAGE^sident := "";
end
}

------------------------------------------------------------------------
HERITAGE -> dpts identc #ident IDC #sident;
#ident{
do
    IDC^ident := identc^txt;
end
}
#sident{
do
    HERITAGE^aHeritage := true;
    HERITAGE^sident := IDC^sident;    
end
}

------------------------------------------------------------------------
---- membres d'une classe
DEFS -> #gen;
#gen{
do
    DEFS^stds := DEFS^tds;
    DEFS^schampsclasse := DEFS^hchampsclasse;
    DEFS^code := "";
end
}

------------------------------------------------------------------------
DEFS ->  ACCES DEF #def DEFS #gen;
#def {
local
    c : CHAMP;
    iv : INFOVAR;
    inf : INFOFONC;
    ch : CHAMPCLASSE;
do
    -- recherche du champ dans la liste des champs
    c := DEFS^hchampsclasse.chercherChamp(DEF^sident);
    if c /= nil then
        error(def_defined, DEF^sident, DEFS^hchampsclasse);
    else
        match DEF^sinfo 
        with INFOVAR then
            iv := DEF^sinfo;    
            -- ajout acces
            iv.setAcces(ACCES^acces);
            --insertion
            ch := new CHAMPCLASSE(DEF^sident, ACCES^acces, DEFS^hchampsclasse.getCurrentDep(), DEF^sinfo );
            DEFS^hchampsclasse.inserer(ch);  
        with INFOFONC then    
            inf := DEF^sinfo;
            --ajout acces
            inf.setAcces(ACCES^acces);
            --insertion
            ch := new CHAMPCLASSE(DEF^sident, ACCES^acces, DEFS^hchampsclasse.getCurrentDep(), DEF^sinfo );
            DEFS^hchampsclasse.inserer(ch);              
        else
            error(not_def, DEF^sident, DEF^sinfo);
        end  
        
        -- transmission des champs 
        DEFS1^hchampsclasse := DEFS^hchampsclasse;  
    end        
end
}
#gen {
do
    DEFS^code := DEF^code + DEFS1^code;
    
    -- remontee de la tds et des schampsclasse
    DEFS^schampsclasse := DEFS1^schampsclasse;
    DEFS^stds := DEFS1^stds;
end
}


------------------------------------------------------------------------
-- definition d'attribut ou de fonction
DEF  ->  TYPE ident #sident #decl DECL #gen;
#decl {
do
    DECL^ident := ident^txt;
    DECL^htype := TYPE^type;
end
}
#sident{
do
    -- remontee de l'ident pour l'ajout dans la TDS
    DEF^sident := ident^txt;
end
}
#gen {
do
    -- remontee de l'info pour la definition
    DEF^sinfo := DECL^sinfo;
    
    DEF^code := DECL^code;    
end
}

------------------------------------------------------------------------
---- constructeur
DEF  ->  identc paro #tds PARFS #stds parf BASE BLOC #gen;
global
    tdsParam : TDS;
    infofonc : INFOFONC;
    t : DTYPE;
#tds {
do  

    PARFS^tds := new TDS(DEF^tds);
end
}     
#stds {
do
    BLOC^hbloc_est_fonction := true;

    tdsParam := PARFS^stds;
    BLOC^tds := new TDS(tdsParam);
    
    -- debut de BLOC : currentDep reset
    DEF^machine.resetCurrentDep();
    -- ajout de 3 pour les variables utilisees par TAM
    DEF^machine.addCurrentDep(3);
    
    -- remontee des info
    t := new DTYPEImpl("constructeur", 0);
    infofonc := new INFOFONC(t, tdsParam);
    DEF^sident := identc^txt;
    DEF^sinfo := infofonc; 
    
    -- transmission du type au bloc
    BLOC^htype := t;  
    
    -- transmission de l ident a BASE
    BASE^ident := identc^txt; 
end
}
#gen{
do  
    DEF^tds.inserer(identc^txt, infofonc);
    
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    DEF^code := BASE^code + DEF^machine.genFonction(identc^txt, tdsParam.getTailleParams(), 0, BLOC^code);
end
}

------------------------------------------------------------------------
---- appel eventuel au constructeur de la classe parente.
BASE -> #gen;
#gen {
do
    BASE^code := "";
end
}

------------------------------------------------------------------------
BASE -> dpts base paro ES parf  #gen;
#gen {
local
    i : INFO;
    ic : INFOCLASSE;
    icp : INFOCLASSE;
    ip : INFO;
    ipf : INFOFONC;
    tdsp : TDS;
    code : STRING;
    tdsParam : TDS;    
do
    code := "";
    -- chercher le constructeur du parent
    i := BASE^tds.chercherClasse(BASE^ident);
    if i = nil then
        error(classe_undefined, BASE^ident, BASE^tds);
    else
        match i with 
        INFOCLASSE then
            ic := i;
            -- obtenir la classe parente
            icp := ic.getParente();
            if icp = nil then
                error(parent_undefined, BASE^ident, ic);
            else
                -- chercher le constructeur dans le contenu de la classe parente
                tdsp := icp.getContenu();
                ip := tdsp.chercherLocalement(new DTYPEImpl("constructeur", 0));
                match ip with
                INFOFONC then
                    ipf := ip;
                    -- code de l appel
                    tdsParam := ipf.getParams();
                    -- comparation des tds pour l appel
                    if ~ES^stds.compareTypeTo(tdsParam) then
                        error(call_nomatch, BASE^ident);  
                    else
                        code := BASE^machine.genArgs(ES^stds) + BASE^machine.genCall(BASE^ident) ;
                    end    
                else
                    error(wrong_typeFonc, BASE^ident + "_parent ", ip);
                end
            end
        else
            error(not_infoclasse, BASE^ident);
        end
    end 
    
    -- generer le code de l appel 

    BASE^code := code;
end
}

------------------------------------------------------------------------
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;

------------------------------------------------------------------------
MODE -> ref #mode;
#mode {
do
    MODE^mode := "ref";
end
}

------------------------------------------------------------------------
MODE -> out #mode; 
#mode {
do
    MODE^mode := "out";
end
}

------------------------------------------------------------------------
F -> true #gen;
#gen{
do
    -- pas une var
    F^sdep := -1;

    F^type := new DTYPEImpl("bool",1);
    F^code_est_adresse := false;
    
    F^code := F^machine.genCst("1");
end
}

------------------------------------------------------------------------
F -> false #gen;
#gen{
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("bool",1);
    F^code_est_adresse := false;
    
    F^code := F^machine.genCst("0");    
end
}

------------------------------------------------------------------------
--F -> this #tds FX;
--#tds {
--do
--    FX^tds := F^tdsClasse;
--end
--}

------------------------------------------------------------------------
-- super
--F -> base FX #gen;
--#gen {
--do
    
--end
--}

------------------------------------------------------------------------
-- null des objets
F -> null2 #gen;
#gen {  
do
    -- pas une var
    F^sdep := -1;
    
    F^type := new DTYPEImpl("PNULL", 1);
    F^code_est_adresse := false;
    F^code := "";
end
}

------------------------------------------------------------------------
-- allocation var
F -> new identc #ident IDC paro ES parf #gen;
#ident{
do
    IDC^ident := identc^txt;
end
}
#gen {
local
    i : INFO;
    ic : INFOCLASSE;
    code : STRING;
    lch : LCHAMPS;
do
    code := "";
    F^code_est_adresse := false;
    F^sdep := 0;
    
    -- recherche de la classe
    i := F^tds.chercherClasse(IDC^sident);
    if i = nil then
        error(classe_undefined, IDC^sident, F^tds);
    else
        match i with
        INFOCLASSE then
            ic := i;
            lch := ic.getChampsClasse();
            F^type := ic.getType();
            F^code_est_adresse := true;
            F^sdep := F^machine.getCurrentDep();
            code := F^machine.genMalloc(lch.getCurrentDep());
        else
            error(not_infoclasse, IDC^sident);
        end
    end
    
    F^code := code;     
end
}

end

