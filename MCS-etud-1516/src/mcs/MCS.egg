-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,OPUN,OPMUL,OPREL,OPADD
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
              

-- IDENT
inh ident   : STRING for DECL, FONCTION,FX;
syn sident  : STRING for PARF;

-- TYPE
syn type    : DTYPE for F,FX, TYPE,PARF,E, STYPE,PTRS, AFFX, A,AX, R,RX,T,TX,OPADD, OPMUL,OPUN,OPREL;
inh htype   : DTYPE for  DECL,FONCTION,PTRS,BLOC,SIX,INSTS,INST,AFFX,AX,FX,RX,TX;


-- TDS
inh tds_asm : TDS for ASM;
inh tds     : TDS     for    BLOC, ENTITE,ENTITES,CHAMP,CHAMPS, INSTS,TYPE,STYPE, INST, FONCTION, DECL, PARFS, PARF, PARFSX, 
                            SIX ,E,ES,ESX,F,FX,T,TX,R,RX,A,AFFX,AX;
syn stds    : TDS for PARFS,PARFSX,ES,ESX;                                                    
                            
-- GC                            
syn code    : STRING for ENTITE , ENTITES,DECL,FONCTION, F,FX, BLOC,SIX, INSTS, INST, E, AFFX,OPUN,OPMUL,OPREL,OPADD,T,TX,A,AX,R,RX;
inh hcode   : STRING for AFFX,AX,RX,FX,TX;
syn code_asm : STRING for ASM;

inh champs : LCHAMPS for CHAMPS, CHAMP;

-- ADRESSE
syn code_est_adresse : BOOLEAN for  AFFX,F, A,AX,R,RX,T,TX,E ;
inh hcode_est_adresse : BOOLEAN for AFFX,AX,RX,TX ;





--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
sugar ref is "ref" ;
sugar out is "out";
sugar namespace is "namespace";
sugar using is "using";
sugar class is "class";
sugar public is "public" ;
sugar private is "private";
sugar dpts is "\:";
sugar bool is "bool";
sugar true is "true";
sugar false is "false";
sugar this is "this";
sugar new is "new" ;
sugar null2 is "null";
sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init #tds ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#tds {
do
    --init de la TDS ( sans parente )
    ENTITES^tds := new TDS(nil);
end
}
-- ecrit le code dans un fichier
global
    code : String;
#gen {
local
do
   -- on suppose la methode "int main()" existante, et sans parametres
   code := machine.genCall("main") + ENTITES^code + machine.genFin();
   -- generation du code de fin du programme
   machine.writeCode(PROGRAMME^source.getFileName(), code);
end
}

------------------------------------------------------------------------
ENTITES -> #gen ;
#gen {
do
    ENTITES^code := "";
end
}

------------------------------------------------------------------------
ENTITES ->  ENTITE ENTITES #gen;
#gen {
do    
    ENTITES^code := ENTITE^code + ENTITES1^code;
end
}    

------------------------------------------------------------------------
-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds #gen;
#tds {
local 
    i : INFO;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    if i != nil then
        error(type_declared, identc^txt, ENTITE^tds);
    else    
        ENTITE^tds.inserer(identc^txt, new INFOTYPE(TYPE^type));
    end    
end
}
#gen {
do
    ENTITE^code := "";        
end
}

------------------------------------------------------------------------
-- definition d'une variable globale ou d'une fonction (commence par une minuscule)
ENTITE ->  TYPE ident #decl DECL #gen;
#decl {
do
    DECL^ident := ident^txt;
    DECL^htype := TYPE^type;
end
}
#gen {
do 
    ENTITE^code := DECL^code;
end
}

-- Variable
DECL -> pv #tds #gen;
global
    i : INFO;
    type : DTYPE;
    e : Emplacement;
#tds {
do
    i := DECL^tds.chercherGlobalement(DECL^ident);
    if i /= nil then
        error(var_declared, DECL^ident);
    else
        type := DECL^htype;
        e := new Emplacement(DECL^machine.getCurrentDep(), DECL^machine.getSB());
        DECL^machine.addCurrentDep(type.getTaille());
        DECL^tds.inserer(DECL^ident,  new INFOVAR(type, e));
    end    
end
}
#gen {
do
    DECL^code := DECL^machine.genVar(type.getTaille());
end
}

------------------------------------------------------------------------
-- déclaration d'une fonction
DECL -> #ident FONCTION #gen;
#ident {
do
    FONCTION^ident := DECL^ident;
    FONCTION^htype := DECL^htype;
end
}
#gen {
do
    DECL^code := FONCTION^code;
end
}

------------------------------------------------------------------------
-- Fonction
FONCTION -> paro #tds PARFS parf BLOC #gen;
global
    i : INFOFONC;
#tds {
do
    BLOC^tds := new TDS(FONCTION^tds);
end
}
#gen{
local
    typeRetour : DTYPE;
    tdsParam : TDS; 
do
    -- TDS
    tdsParam := PARFS^stds;
    i := new INFOFONC(FONCTION^htype, tdsParam);
    FONCTION^tds.inserer(FONCTION^ident,  i);
    typeRetour :=i.getType();
    
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    FONCTION^code := FONCTION^machine.genFonction(FONCTION^ident, tdsParam.getTailleParams(), typeRetour.getTaille(), BLOC^code);
end
}

------------------------------------------------------------------------
-- parametres de fonctions
PARFS ->  #tds;
#tds{
do
    PARFS^stds := new TDS(nil);
end
}


------------------------------------------------------------------------
-- multi paramètres
PARFS -> PARF #tds PARFSX #stds;
global
    tds:TDS;
#tds {
do    
    tds := PARFS^tds;
    tds.inserer(PARF^sident, new INFOTYPE(PARF^type));
    PARFSX^tds := tds;
end
}
#stds {
do
    PARFS^stds := PARFSX^stds; 
end
}

------------------------------------------------------------------------
-- fin parametre
PARFSX -> #stds ;
#stds {
do
    PARFSX^stds := new TDS(nil);
end
}

-- multi parametres
PARFSX -> virg PARF #tds PARFSX #stds;
#tds {
local
    tds : TDS;
do 
    -- transmission des tds;
    tds := PARFSX^tds;
    tds.inserer(PARF^sident, new INFOTYPE(PARF^type));
    PARFSX1^tds := tds;
end
}
#stds {
do
    PARFSX^stds := PARFSX1^stds;
end
}

------------------------------------------------------------------------
-- parametre fonction
PARF -> TYPE ident #tds;
#tds {
do
    PARF^type := TYPE^type;
    PARF^sident := ident^txt;
end
}

------------------------------------------------------------------------
-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE #htype PTRS #type;
#htype {
do
    PTRS^htype := STYPE^type; 
end
}
#type {
do
    TYPE^type := PTRS^type;
end
}

------------------------------------------------------------------------
-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type {
do
    PTRS^type := PTRS^htype;
end
}

------------------------------------------------------------------------
-- variable qualifiee 
PTRS -> mult #htype PTRS #type;
#htype {
do
    PTRS1^htype := new POINTEUR(PTRS^htype);
end
}
#type {
do
    PTRS^type := PTRS1^type;
end
}

------------------------------------------------------------------------
-- types de base
STYPE-> void #type ;
#type {
do
    STYPE^type := new DTYPEImpl("void",0);
end
}

------------------------------------------------------------------------
STYPE-> int #type;
#type {
do
    STYPE^type := new DTYPEImpl("int",1);
end
}

------------------------------------------------------------------------
STYPE-> char #type;
#type {
do
    STYPE^type := new DTYPEImpl("char",1);
end
}

------------------------------------------------------------------------
-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
local
    i : INFO ;
do
    i := STYPE^tds.chercherGlobalement(identc^txt);
    if i = nil then
        error(type_undefined, identc^txt);
    else    
        match i with INFOTYPE then
            STYPE^type := i.getType();
        else
            error(not_infotype, identc^txt);    
        end
    end
end
}

------------------------------------------------------------------------ 
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type;
global 
 lc : LCHAMPS ;
#ch {
do
  lc := new LCHAMPS();
  CHAMPS^champs := lc;
end
}
#type {
 do
   STYPE^type := new STRUCT(lc);
 end
}

------------------------------------------------------------------------
CHAMPS -> ;

------------------------------------------------------------------------
-- un nom de champ commence par une minuscule
CHAMPS ->  CHAMP CHAMPS ;

------------------------------------------------------------------------
CHAMP -> TYPE ident pv #champ;
#champ {
 local
  c : CHAMP ;
 do
    
    c := CHAMP^champs.chercherChamp(ident^txt);
    if c /= nil then
        error(champ_declared, ident^txt, CHAMP^champs);
    else    
        CHAMP^champs.inserer(new CHAMP(ident^txt, TYPE^type, CHAMP^champs.getCurrentDep()));
    end    
 end
}

------------------------------------------------------------------------
-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS acf #gen;
#tds {
do
   INSTS^tds := new TDS(BLOC^tds);
   
   -- debut de BLOC : currentDep reset
   BLOC^machine.resetCurrentDep();
end
}
#gen {
do
    -- fin de BLOC : POP currentDep dans le BLOC
    BLOC^code := INSTS^code + BLOC^machine.genFree();
end
}

------------------------------------------------------------------------
-- instructions --
INSTS ->  #gen ;
#gen {
do
  INSTS^code := "";
end
}

------------------------------------------------------------------------
INSTS ->  INST INSTS #gen ;
#gen {
do
  INSTS^code := INST^code + INSTS1^code;
end
}

------------------------------------------------------------------------
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident #htype AFFX pv #tds #type #gen ;
#htype {
do
    -- transmission de type
    AFFX^htype := TYPE^type;
    -- transmission de l adresse
    AFFX^hcode_est_adresse := false;
    AFFX^hcode := "";
end
}
#tds {
local
    i : INFO ;
    e : Emplacement;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(var_declared, ident^txt);
    else 
        e := new Emplacement(INST^machine.getCurrentDep(), INST^machine.getSB());   
        INST^machine.addCurrentDep(TYPE^type.getTaille());
        i := new INFOVAR(TYPE^type, e);
        INST^tds.inserer(ident^txt, i);
    end
end
}
#type {
do
    -- controle de type
   if ~TYPE^type.compareTo(AFFX^type) then
      error(B_11, TYPE^type, AFFX^type);
   end
   
end
}
#gen {
do
    INST^code := AFFX^code;
end
}

------------------------------------------------------------------------
-- instruction expression (affectation et appel de procedure)
INST -> E pv #gen;
#gen {
do
    INST^code := E^code;
end
}

------------------------------------------------------------------------
-- bloc d'instructions
INST -> BLOC  #code;
#code {
do
    INST^code := BLOC^code;        
end
}


------------------------------------------------------------------------
-- conditionnelle
INST ->  si paro E #type parf BLOC SIX #gen;
#type {
do
   if ~E^type.compareTo(new DTYPEImpl("int", 1)) then
      error(not_int, E^type);
   end
end
}
#gen {
do
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;
end
}

------------------------------------------------------------------------
-- bloc sinon 
SIX ->    sinon BLOC #gen;
#gen {
do
    SIX^code := BLOC^code;
end
}

------------------------------------------------------------------------
-- pas de bloc sinon
SIX -> #gen;
#gen{
do
    SIX^code := "";
end
}

------------------------------------------------------------------------
-- retour de fonction
INST ->  retour E pv #type #gen;
#type {
do
    -- controle de type de retour
   if ~INST^htype.compareTo(E^type) then
      error(returnType_notCompatible, INST^htype, E^type);
   end    
    
end
}
#gen {
do
    INST^code := E^code;
end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

------------------------------------------------------------------------
E -> A #type AFFX #gen;
#type {
do    
    AFFX^hcode_est_adresse := A^code_est_adresse;
    
    E^type := A^type;
    -- type pour permettre le controle d'erreur au moment de l'affectation
    AFFX^htype := A^type;
    AFFX^hcode := A^code;
end
}
#gen {
do
    E^code_est_adresse := AFFX^code_est_adresse;
    
    E^code := AFFX^code;  
end
}

------------------------------------------------------------------------
-- affectation
AFFX -> affect A  #type #gen;
#type {
-- controle de type
do
    AFFX^code_est_adresse := false;    
    
    if ~AFFX^htype.compareTo(A^type) then
        error(affect_notCompatible, AFFX^htype.getNom() ,A^type.getNom());
    else
        -- remonter le type pour la declaration avec affectation
        AFFX^type := A^type;    
    end
end
}
#gen {
local 
  code : STRING;
do  
    if AFFX^hcode_est_adresse then
        code := AFFX^hcode +A^code + AFFX^machine.genWriteIndirectMem(AFFX^htype.getTaille());
    else
        code := AFFX^hcode + A^code + AFFX^machine.genWriteMem(AFFX^machine.getCurrentDep(), AFFX^htype.getTaille());
       end 
      AFFX^code := code;
  end
}

------------------------------------------------------------------------
AFFX ->#type #gen;
#type {
do
    AFFX^code_est_adresse := AFFX^hcode_est_adresse;
    
    AFFX^type := AFFX^htype;
end
}
#gen {
do
    AFFX^code := AFFX^hcode;
end
}

------------------------------------------------------------------------
-- relation
A -> R #type AX #gen;
#type{
do 
    -- transmission du type de R pour le controle de type
    AX^htype := R^type;
    -- on remonte le type
    A^type := R^type;
    
    AX^hcode := R^code;
    AX^hcode_est_adresse := R^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    A^code := R^code + AX^code;

    A^code_est_adresse := AX^code_est_adresse;   
end
}

------------------------------------------------------------------------
AX -> OPREL R #type #gen;
#type {
do
    -- controle de type
    if ~AX^htype.compareOpBin(OPREL^type, R^type) then
        error(B_10, AX^htype.getNom());
    else
    -- on remonte le type
        AX^type := R^type;         
    end 
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur relationnel
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    AX^code := R^code + OPREL^code;     
    -- membre de droite lors de la relation -> ce n est pas une adresse
    AX^code_est_adresse := false;
end
}


------------------------------------------------------------------------
AX ->  #type #gen;
#type {
do
    AX^type := AX^htype;

    AX^code_est_adresse := AX^hcode_est_adresse;
end
}
#gen {
do
    AX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs relationnels
OPREL -> inf #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELINF",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILss");
end
}

------------------------------------------------------------------------
OPREL -> sup #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELSUP",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGtr");    
end
}

------------------------------------------------------------------------
OPREL -> infeg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELINFEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILeq");    
end
}

------------------------------------------------------------------------
OPREL -> supeg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELSUPEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGeq");    
end
}

------------------------------------------------------------------------
OPREL -> eg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IEq");    
end
}

------------------------------------------------------------------------
OPREL -> neg #type;
#type {
do
    OPREL^type := new DTYPEImpl("OPRELNEG",1);
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("INeq");    
end
}

------------------------------------------------------------------------
-- additions multiples
R -> T #type RX #gen;
#type{
do
    -- transmission du type de R pour le controle de type
    RX^htype := T^type;
    -- on remonte le type
    R^type := T^type;
    
    RX^hcode := T^code;
    RX^hcode_est_adresse := T^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    R^code := T^code + RX^code;

    R^code_est_adresse := RX^code_est_adresse;  
end
}

------------------------------------------------------------------------
-- additions ...
RX ->   OPADD  T RX  #type #gen;
#type {
do
    -- controle de type
    if ~RX^htype.compareOpBin(OPADD^type, T^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, T^type);    
    elseif ~RX^htype.compareOpBin(OPADD^type, RX1^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, RX1^type);
    else
    -- on remonte le type
        RX^type := T^type;         
    end 
end
}
#gen {
do
    -- opadd donc ce n est plus une adresse
    RX^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur add
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    RX^code := T^code + RX1^code + OPADD^code;         
end
}


------------------------------------------------------------------------
RX -> #type;
#type {
do
    RX^type := RX^htype;
    -- adresse
    RX^code_est_adresse := RX^hcode_est_adresse;
    -- GC
    RX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs additifs
OPADD -> plus #type;
#type {
do  
    OPADD^type := new DTYPEImpl("OPADDPLUS",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("IAdd");     
end
}

------------------------------------------------------------------------
OPADD -> moins #type;
#type {
do
    OPADD^type := new DTYPEImpl("OPADDMOINS",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("ISub");     
end
}

------------------------------------------------------------------------
OPADD -> ou #type;
#type {
do
    OPADD^type := new DTYPEImpl("OPADDOU",1);
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("BOr");     
end
}

------------------------------------------------------------------------
-- multiplication, ...
T -> F #type TX #gen ;
#type{
do
    -- transmission du type de R pour le controle de type
    TX^htype := F^type;
    -- on remonte le type
    T^type := F^type;
    
    TX^hcode := F^code;
    TX^hcode_est_adresse := F^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    T^code := F^code + TX^code;

    T^code_est_adresse := TX^code_est_adresse;
end
}

------------------------------------------------------------------------
TX -> OPMUL F TX  #type #gen;
#type {
do
    -- controle de type
    if ~TX^htype.compareOpBin(OPMUL^type, F^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, F^type);    
    elseif ~TX^htype.compareOpBin(OPMUL^type, TX1^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, TX1^type);
    else
    -- on remonte le type
        TX^type := F^type;     
    end
    
    TX^code_est_adresse := false; 
  
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur multiple
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    TX^code := F^code + TX1^code + OPMUL^code;    
end
}

------------------------------------------------------------------------
TX -> #type ;
#type {
do
    TX^type := TX^htype;
    TX^code := "";
    
    TX^code_est_adresse := TX^hcode_est_adresse;
end
}

------------------------------------------------------------------------
-- operateurs multiplicatifs
OPMUL -> mult #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULMULT",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMul");    
end
}

------------------------------------------------------------------------
OPMUL -> div #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULDIV",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IDiv");      
end
}

------------------------------------------------------------------------
OPMUL -> mod #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULMOD",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMod");      
end
}

------------------------------------------------------------------------
OPMUL -> et #type;
#type {
do
    OPMUL^type := new DTYPEImpl("OPMULET",1);
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("BAnd");      
end
}

-- expressions de base

------------------------------------------------------------------------
-- Constante entiere --
F -> entier #gen ;
#gen {
do
    F^type := new DTYPEImpl("int", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(entier^txt);
end
}

------------------------------------------------------------------------
-- Constante chaine
F -> chaine #gen;
#gen {
do
    F^type := new DTYPEImpl("chaine", 3);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(chaine^txt);
end
}

------------------------------------------------------------------------
-- Constante caractere
F -> caractere #gen;
#gen {
do
    F^type := new DTYPEImpl("char", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(caractere^txt);
end
}

------------------------------------------------------------------------
-- expression unaire
F -> OPUN  F #type #gen;
#type {
do
    -- controle de type
    if ~F1^type.compareOpUn(OPUN^type) then
        error(B_10, OPUN^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := F1^type;         
    end 
  
end
}
#gen {
do
    F^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur unaire
    -- on empile d abord la valeur puis on fait un SUBR op
    F^code := F1^code + OPUN^code;
end
}

------------------------------------------------------------------------
-- operateurs unaires
OPUN -> plus #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNPLUS",1);
    -- SUBR op
    OPUN^code := "";
end
}

------------------------------------------------------------------------
OPUN -> moins #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNMOINS",1);
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("Ineg");
end
}

------------------------------------------------------------------------
OPUN -> non #type;
#type {
do
    OPUN^type := new DTYPEImpl("OPUNNON",1);
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("BNeg");    
end
}

------------------------------------------------------------------------
-- pointeur NULL
F -> null #type ;
#type {  
do
    F^type := new DTYPEImpl("PNULL", 1);
    F^code_est_adresse := false;
    F^code := "";
end
}

------------------------------------------------------------------------
-- expression parenthesee
F ->  paro E parf #addr FX #type #gen;
#addr {
do
    FX^ident := "";

    F^code_est_adresse := E^code_est_adresse;
    -- type de FX est le type de l expression de gauche
    FX^hcode := E^code;
    FX^htype := E^type;
end
}
#type {
do
    -- controle de type
    if ~E^type.compareTo(FX^type) then
        error(B_12, E^type.getNom(), FX^type.getNom());
    else
    -- on remonte le type
        F^type := E^type;         
    end 
  
end
}
#gen {
do
    
    -- GC
    F^code := E^code + FX^code;
end
}

------------------------------------------------------------------------
F ->  paro TYPE parf  F  #type #gen;
#type {
do
    -- controle de type
    if ~TYPE^type.compareTo(F1^type) then
        error(B_12, TYPE^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := TYPE^type;         
    end 
end
}
#gen {
do
    -- remontee des infos
    F^code := F1^code;
    F^code_est_adresse := F1^code_est_adresse;
end
}

------------------------------------------------------------------------
F -> mult F #type #addr;
#type {
do
    match F1^type with POINTEUR then
        F^type := F1^type;
        F^code_est_adresse := true;
    else
        error(not_pointeur, F1^type.getNom());
    end        
end
}
#addr {
do
    -- code acces a un pointeur
    F^code := F^machine.genReadIndirectMem(1);
end
}

------------------------------------------------------------------------
F -> ident #htype FX #gen;
global 
  iv : INFOVAR ;
  infofonc : INFOFONC;
  t : DTYPE;
#htype {
local
    i:INFO;
    code : STRING;
do
    -- ident pour l'appel de fonction
    FX^ident := ident^txt;

    i := F^tds.chercherGlobalement(ident^txt);
    if i = null then
        error(var_not_found, ident^txt);
    end
    match i 
    with INFOVAR then
        iv := i;
        t := iv.getType();
        FX^hcode := F^machine.genAdr(iv.getTaille());
        F^code_est_adresse := true;
    with INFOFONC then
       infofonc := i;  
       t := infofonc.getType();
       FX^hcode := "";
       F^code_est_adresse := false;  
    else
        error(B_08, ident^txt);
    end
    FX^htype := t;
end
}  
#gen{
do
    F^type := FX^type;
    F^code := FX^code;    
end
}

------------------------------------------------------------------------
FX -> #gen;
#gen {
do
  FX^type := FX^htype;
  FX^code := "";
end
}

------------------------------------------------------------------------
-- acces champ
FX ->   pt  ident #a FX #gen;
#gen {
do
  FX^type := FX1^type;
  FX^code :=FX1^code;
end
}
#a {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do


end
}

------------------------------------------------------------------------
-- acces champ pointeur
FX ->   arrow  ident FX #type #gen;
#type {
do
    FX^type := FX1^type;    
end
}
#gen {
do
    FX^code := "";        
end
}

------------------------------------------------------------------------
-- appel de sous-programme
FX ->   paro ES parf #htds FX #type #gen;
#htds {
do
    FX1^tds := ES^stds;
end
}
#type {
do
    FX^type := FX1^type;
end
}   
#gen {
do
    -- appel du sous-programme à partir de l'étiquette
    FX^code := FX^machine.genArgs(ES^stds) + FX^machine.genCall(FX^ident);
end
}

------------------------------------------------------------------------
-- arguments appel de sous-programme
ES -> #tds;
#tds {
do
    ES^stds := new TDS(nil);
end
}

------------------------------------------------------------------------
ES -> E #tds ESX #stds ;
global
    tds:TDS;
#tds {
do
    tds := ES^tds;
    -- appel : <"code", INFOTYPE>
    -- Rappel: la LinkedHashMap garantie l'ordre des get = l'ordre des put
    tds.inserer(E^code, new INFOTYPE(E^type));
    ESX^tds := tds;
end  
}
#stds {
do
    ES^stds := ESX^stds;
end
}

------------------------------------------------------------------------
ESX -> #stds ;
#stds {
do
    ESX^stds := ESX^tds;
end
}


------------------------------------------------------------------------
ESX -> virg E #tds ESX #stds;
#tds {
local
    tds : TDS;
do 
    tds := ESX^tds;
    -- appel : <"code", INFOTYPE>
    -- Rappel: la LinkedHashMap garantie l'ordre des get = l'ordre des put
    tds.inserer(E^code, new INFOTYPE(E^type));
    ESX1^tds := tds;
end
}
#stds {
do
    ESX^stds := ESX1^stds;
end
}

------------------------------------------------------------------------
------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^code := ASM^code_asm;
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end

