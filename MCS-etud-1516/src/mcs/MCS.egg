-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,OPUN,OPMUL,OPREL,OPADD
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
              

--      IDENT
inh ident : STRING for DECL, FONCTION;

--      TYPE
syn type : DTYPE for F,FX, TYPE,E, STYPE,PTRS, AFFX, A,AX, R,RX,T,TX,OPADD, OPMUL,OPUN,OPREL;
inh htype : DTYPE for  DECL,FONCTION,PTRS,BLOC,SIX,INSTS,INST,AFFX,AX,FX,RX,TX;


--      TDS
inh tds_asm : TDS for ASM;
inh tds    : TDS     for    BLOC, ENTITE,ENTITES,CHAMP,CHAMPS, INSTS,TYPE,STYPE, INST, FONCTION, DECL, PARFS, PARF, PARFSX, 
                            SIX ,E,ES,ESX,F,FX,T,TX,R,RX,A,AFFX,AX;
                            
--      GC                            
syn code : STRING for ENTITE , ENTITES,DECL,FONCTION, F,FX, BLOC,SIX, INSTS, INST, E, AFFX,OPUN,OPMUL,OPREL,OPADD,T,TX,A,AX,R,RX;
--inh hcode : STRING for ;
syn code_asm : STRING for ASM;

inh champs : LCHAMPS for CHAMPS, CHAMP;

--      ADRESSE
syn code_est_adresse : BOOLEAN for  AFFX,F, A,AX,R,RX,T,TX,E ;
inh hcode_est_adresse : BOOLEAN for AFFX,AX,RX,TX ;


--      AFFECTATION
syn est_affectable : BOOLEAN for A,T,R,F,E,FX;




--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init #tds ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#tds {
do
    --init de la TDS ( sans parente )
    ENTITES^tds := new TDS(nil);
end
}
-- ecrit le code dans un fichier
global
    code : String;
#gen {
local
do
   -- on suppose la methode "int main()" existante, et sans parametres
   code := machine.genCall("main") + ENTITES^code + machine.genFin();
   -- generation du code de fin du programme
   machine.writeCode(PROGRAMME^source.getFileName(), code);  
end
}

------------------------------------------------------------------------
ENTITES -> #gen ;
#gen {
do
    ENTITES^code := "";
end
}

------------------------------------------------------------------------
ENTITES ->  ENTITE ENTITES #gen;
#gen {
do
    ENTITES^code := ENTITE^code + ENTITES1^code;
end
}    

------------------------------------------------------------------------
-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #tds #gen;
#tds {
local
    i : INFOTYPE ;
do
    i := ENTITE^tds.chercherGlobalement(identc^txt);
    ENTITE^tds.inserer(identc^txt,  i);
end
}
#gen {
do
    ENTITE^code := "";        
end
}

------------------------------------------------------------------------
-- definition d'une variable globale ou d'une fonction (commence par une minuscule)
ENTITE ->  TYPE ident #decl DECL #gen;
#decl {
do
    DECL^ident := ident^txt;
    DECL^htype := TYPE^type;
end
}
#gen {
do 
    ENTITE^code := "";
end
}

-- Variable
DECL -> pv #tds #gen;
global
    i : INFOVAR ;
    type : DTYPE;
#tds {
do
    type := DECL^htype;
    DECL^machine.addCurrentDep(type.getTaille());
    i := new INFOVAR(type, DECL^machine.getCurrentDep());
    DECL^tds.inserer(DECL^ident,  i);
end
}
#gen {
do
    DECL^code := DECL^machine.genVar(type.getTaille());
end
}

------------------------------------------------------------------------
-- déclaration d'une fonction
DECL -> #ident FONCTION #gen;
#ident {
do
    FONCTION^ident := DECL^ident;
    FONCTION^htype := DECL^htype;
end
}
#gen {
do
    DECL^code := FONCTION^code;
end
}

------------------------------------------------------------------------
-- Fonction
FONCTION -> paro #init PARFS parf BLOC #gen;
global
    i : INFOFONC; 
    tdsParam : TDS;
#init {
do
    tdsParam := new TDS(FONCTION^tds);
    PARFS^tds := tdsParam; 
    BLOC^tds := new TDS(tdsParam);
end
}
#gen{
do
    -- TDS
    i := new INFOFONC(FONCTION^htype, tdsParam);
    FONCTION^tds.inserer(FONCTION^ident,  i);
    
    
    -- generer le prologue et l'epilogue de la fonction
    -- etiquette + taille des parametres + taille retour + code des instructions
    FONCTION^code := FONCTION^machine.genFonction(FONCTION^ident, tdsParam.getTailleParams(), tdsParam.getTailleRetour(), BLOC^code);
end
}

------------------------------------------------------------------------
-- parametres de fonctions
PARFS ->  ;


------------------------------------------------------------------------
-- multi paramètres
PARFS -> #tds PARF PARFSX ;
global
    tds:TDS;
#tds {
do
    tds := new TDS(PARFS^tds);
    PARF^tds := tds;
    PARFSX^tds := tds;
end
}

------------------------------------------------------------------------
-- fin parametre
PARFSX ->  ;
-- Done

-- multi parametres
PARFSX -> #tds virg PARF PARFSX ;
#tds {
do 
    -- transmission des tds;
    PARF^tds := PARFSX^tds;
    PARFSX1^tds := PARFSX^tds;
end
}

------------------------------------------------------------------------
-- parametre fonction
PARF -> TYPE ident #tds;
#tds {
local
    i : INFO ;
do
    -- creer un type
    i := new INFOVAR(TYPE^type);
    PARF^tds.inserer(ident^txt, i);
end
}

------------------------------------------------------------------------
-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE #htype PTRS #type;
#htype {
do
    PTRS^htype := STYPE^type; 
end
}
#type {
do
    TYPE^type := PTRS^type;
end
}

------------------------------------------------------------------------
-- type de base
-- des * pour definir un pointeur
PTRS -> #type;
#type {
do
    PTRS^type := PTRS^htype;
end
}

------------------------------------------------------------------------
-- variable qualifiee 
PTRS -> mult #htype PTRS #type;
#htype {
do
    PTRS1^htype := new POINTEUR(PTRS^htype, 1);
end
}
#type {
do
    PTRS^type := PTRS1^type;
end
}

------------------------------------------------------------------------
-- types de base
STYPE-> void #type ;
#type {
do
    STYPE^type := new DTYPE("VOID");
end
}

------------------------------------------------------------------------
STYPE-> int #type;
#type {
do
    STYPE^type := new DTYPE("INT");
end
}

------------------------------------------------------------------------
STYPE-> char #type;
#type {
do
    STYPE^type := new DTYPE("CHAR");
end
}

------------------------------------------------------------------------
-- nom de type (commence par une majuscule)
STYPE -> identc #type;
#type {
local
    i : INFO ;
do
    i := STYPE^tds.chercherGlobalement(identc^txt);
    if i = nil then
        error(type_undefined, identc^txt);
    else    
        match i with INFOTYPE then
            STYPE^type := i.getType();
        else
            error(not_infotype, identc^txt);    
        end
    end
end
}

------------------------------------------------------------------------ 
-- et struct
STYPE -> struct aco #ch CHAMPS acf #type;
global 
 lc : LCHAMPS ;
#ch {
do
  lc := new LCHAMPS();
  CHAMPS^champs := lc;
end
}
#type {
 do
   STYPE^type := new STRUCT(lc);
 end
}

------------------------------------------------------------------------
CHAMPS -> ;

------------------------------------------------------------------------
-- un nom de champ commence par une minuscule
CHAMPS ->  CHAMP CHAMPS ;

------------------------------------------------------------------------
CHAMP -> TYPE ident pv #champ;
#champ {
 local
  c : CHAMP ;
 do
     c := new CHAMP(ident^txt, TYPE^type, CHAMP^champs.getTaille());
     CHAMP^champs.inserer(c);
 end
}

------------------------------------------------------------------------
-- corps de fonction et bloc d'instructions
BLOC ->  aco #tds INSTS acf #gen;
#tds {
do
   INSTS^tds := new TDS(BLOC^tds);
   
   -- debut de BLOC : currentDep reset
   BLOC^machine.resetCurrentDep();
end
}
#gen {
do
    -- fin de BLOC : POP currentDep dans le BLOC
    BLOC^code := INSTS^code + BLOC^machine.genFree();
end
}

------------------------------------------------------------------------
-- instructions --
INSTS ->  #gen ;
#gen {
do
  INSTS^code := "";
end
}

------------------------------------------------------------------------
INSTS ->  INST INSTS #gen ;
#gen {
do
  INSTS^code := INST^code + INSTS1^code;
end
}

------------------------------------------------------------------------
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident #htype AFFX pv #tds #type #gen ;
#tds {
local
    i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(var_declared, ident^txt);
    else    
        INST^machine.addCurrentDep(TYPE^type.getTaille());
        i := new INFOVAR(TYPE^type, INST^machine.getCurrentDep());
        INST^tds.inserer(ident^txt, i);
        
    end
end
}
#htype {
do
    -- transmission de type
    AFFX^htype := TYPE^type;
    -- transmission de l adresse
    AFFX^hcode_est_adresse := false;
end
}
#type {
do
    -- controle de type
   if ~TYPE^type.compareTo(AFFX^type) then
      error(B_11, TYPE^type, AFFX^type);
   end
   
end
}
#gen {
do
    INST^code := AFFX^code;
end
}

------------------------------------------------------------------------
-- instruction expression (affectation et appel de procedure)
INST -> E pv #gen;
#gen {
do
    INST^code := E^code;
end
}

------------------------------------------------------------------------
-- bloc d'instructions
INST -> BLOC  #code;
#code {
do
    INST^code := BLOC^code;        
end
}


------------------------------------------------------------------------
-- conditionnelle
INST ->  si paro E #type parf BLOC SIX #gen;
#type {
do
   if ~E^type.compareTo(new DTYPE("INT", 1)) then
      error(not_int, E^type);
   end
end
}
#gen {
do
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code) ;
end
}

------------------------------------------------------------------------
-- bloc sinon 
SIX ->    sinon BLOC #gen;
#gen {
do
    SIX^code := BLOC^code;
end
}

------------------------------------------------------------------------
-- pas de bloc sinon
SIX -> #gen;
#gen{
do
    SIX^code := "";
end
}

------------------------------------------------------------------------
-- retour de fonction
INST ->  retour E pv #type #gen;
#type {
do
    -- controle de type de retour
   if ~INST^htype.compareTo(E^type) then
      error(returnType_notCompatible, INST^htype, E^type);
   end    
    
end
}
#gen {
do
    INST^code := E^code;
end
}


-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

------------------------------------------------------------------------
E -> A #aff #type AFFX #gen;
#aff {
do
    -- transmission du bool hcode est adresse
    AFFX^hcode_est_adresse := A^code_est_adresse;
    
    --gestion d'erreur en cas de probleme d affectation
    if ~A^est_affectable then
        error(B_14);
    else
        E^est_affectable := A^est_affectable;
    end
end
}
#type {
do
    E^type := A^type;
    -- type pour permettre le controle d'erreur au moment de l'affectation
    AFFX^htype := A^type;
end
}
#gen {
do
    E^code_est_adresse := AFFX^code_est_adresse;
    
    E^code := AFFX^code;  
end
}

------------------------------------------------------------------------
-- affectation
AFFX -> affect A  #type #gen;
#type {
-- controle de type
do
    AFFX^code_est_adresse := false;
    
    -- remonter le type pour la declaration avec affectation
    AFFX^type := AFFX^htype;
    
    if ~AFFX^htype.compareTo(A^type) then
        error(affect_notCompatible, AFFX^htype.getNom() ,A^type.getNom());
    end
end
}
#gen {
local 
  code : STRING;
do  
      code :=  AFFX^machine.genComment("Valeur") + A^code ;
      if AFFX^hcode_est_adresse then
        code := code + AFFX^machine.genComment("Adresse") +
                     A^code + AFFX^machine.genWriteIndirectMem(AFFX^htype.getTaille());
      else
        code := code + AFFX^machine.genWriteMem(AFFX^machine.getCurrentDep(), AFFX^htype.getTaille());
       end 
      AFFX^code := code; 
  end
}

------------------------------------------------------------------------
AFFX ->#type #gen;
#type {
do
    AFFX^code_est_adresse := AFFX^hcode_est_adresse;
    
    AFFX^type := AFFX^htype;
end
}
#gen {
do
    AFFX^code := "";
end
}

------------------------------------------------------------------------
-- relation
A -> R #aff #type AX #gen;
#aff {
do
    A^est_affectable := R^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    AX^htype := R^type;
    -- on remonte le type
    A^type := R^type;
    
    AX^hcode_est_adresse := R^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    A^code := R^code + AX^code;

    A^code_est_adresse := AX^code_est_adresse;   
end
}

------------------------------------------------------------------------
AX -> OPREL R #type #gen;
#type {
do
    -- controle de type
    if ~AX^htype.compareTo(OPREL^type, R^type) then
        error(B_10, AX^htype.getNom());
    else
    -- on remonte le type
        AX^type := R^type;         
    end 
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur relationnel
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    AX^code := R^code + OPREL^code;     
    -- membre de droite lors de la relation -> ce n est pas une adresse
    AX^code_est_adresse := false;
end
}


------------------------------------------------------------------------
AX ->  #type #gen;
#type {
do
    AX^type := AX^htype;

    AX^code_est_adresse := AX^hcode_est_adresse;
end
}
#gen {
do
    AX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs relationnels
OPREL -> inf #type;
#type {
do
    OPREL^type := new DTYPE("OPRELINF");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILss");
end
}

------------------------------------------------------------------------
OPREL -> sup #type;
#type {
do
    OPREL^type := new DTYPE("OPRELSUP");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGtr");    
end
}

------------------------------------------------------------------------
OPREL -> infeg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELINFEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("ILeq");    
end
}

------------------------------------------------------------------------
OPREL -> supeg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELSUPEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IGeq");    
end
}

------------------------------------------------------------------------
OPREL -> eg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("IEq");    
end
}

------------------------------------------------------------------------
OPREL -> neg #type;
#type {
do
    OPREL^type := new DTYPE("OPRELNEG");
    -- SUBR op
    OPREL^code := OPREL^machine.genOp("INeq");    
end
}

------------------------------------------------------------------------
-- additions multiples
R -> T #aff #type RX #gen;
#aff {
do
    R^est_affectable := T^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    RX^htype := T^type;
    -- on remonte le type
    R^type := T^type;
    
    RX^hcode_est_adresse := T^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    R^code := T^code + RX^code;

    R^code_est_adresse := RX^code_est_adresse;  
end
}

------------------------------------------------------------------------
-- additions ...
RX ->   OPADD  T RX  #type #gen;
#type {
do
    -- controle de type
    if ~RX^htype.compareTo(OPADD^type, T^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, T^type);    
    elseif ~RX^htype.compareTo(OPADD^type, RX1^type) then
        error(B_10, RX^htype.getNom(), OPADD^type, RX1^type);
    else
    -- on remonte le type
        RX^type := T^type;         
    end 
end
}
#gen {
do
    -- opadd donc ce n est plus une adresse
    RX^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur add
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    RX^code := T^code + RX1^code + OPADD^code;         
end
}


------------------------------------------------------------------------
RX -> #type;
#type {
do
    RX^type := RX^htype;
    -- adresse
    RX^code_est_adresse := RX^hcode_est_adresse;
    -- GC
    RX^code := "";
end
}

------------------------------------------------------------------------
-- operateurs additifs
OPADD -> plus #type;
#type {
do
    OPADD^type := new DTYPE("OPADDPLUS");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("IAdd");     
end
}

------------------------------------------------------------------------
OPADD -> moins #type;
#type {
do
    OPADD^type := new DTYPE("OPADDMOINS");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("ISub");     
end
}

------------------------------------------------------------------------
OPADD -> ou #type;
#type {
do
    OPADD^type := new DTYPE("OPADDOU");
    -- SUBR op
    OPADD^code := OPADD^machine.genOp("BOr");     
end
}

------------------------------------------------------------------------
-- multiplication, ...
T -> F #aff #type TX #gen ;
#aff {
do
    T^est_affectable := F^est_affectable;
end
}
#type{
do
    -- transmission du type de R pour le controle de type
    TX^htype := F^type;
    -- on remonte le type
    T^type := F^type;
    
    TX^hcode_est_adresse := F^code_est_adresse;
end
}
#gen {
do
    -- generation du code qui renvoie la valeur correspond a la relation
    T^code := F^code + TX^code;

    T^code_est_adresse := TX^code_est_adresse;
end
}

------------------------------------------------------------------------
TX -> OPMUL #tds F TX  #type #gen;
#tds {
do
    TX1^tds := TX^tds;
end
}
#type {
do
    -- controle de type
    if ~TX^htype.compareTo(OPMUL^type, F^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, F^type);    
    elseif ~TX^htype.compareTo(OPMUL^type, TX1^type) then
        error(B_10, TX^htype.getNom(), OPMUL^type, TX1^type);
    else
    -- on remonte le type
        TX^type := F^type;     
    end
    
    TX^code_est_adresse := false; 
  
end
}
#gen {
do
    -- remontee du code pour prendre en compte l operateur multiple
    -- on empile d abord les 2 valeurs puis on fait un SUBR op
    TX^code := F^code + TX1^code + OPMUL^code;    
end
}

------------------------------------------------------------------------
TX -> #type ;
#type {
do
    TX^type := TX^htype;
    TX^code := "";
    
    TX^code_est_adresse := TX^hcode_est_adresse;
end
}

------------------------------------------------------------------------
-- operateurs multiplicatifs
OPMUL -> mult #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULMULT");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMul");    
end
}

------------------------------------------------------------------------
OPMUL -> div #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULDIV");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IDiv");      
end
}

------------------------------------------------------------------------
OPMUL -> mod #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULMOD");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("IMod");      
end
}

------------------------------------------------------------------------
OPMUL -> et #type;
#type {
do
    OPMUL^type := new DTYPE("OPMULET");
    -- SUBR op 
    OPMUL^code := OPMUL^machine.genOp("BAnd");      
end
}

-- expressions de base

------------------------------------------------------------------------
-- Constante entiere --
F -> entier #aff #gen ;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("INT", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCst(entier^txt);
end
}

------------------------------------------------------------------------
-- Constante chaine
F -> chaine #aff #gen;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("CHAINE", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genChaine(chaine^txt);
end
}

------------------------------------------------------------------------
-- Constante caractere
F -> caractere #aff #gen;
#aff {
do
    -- non affectable car constante
    F^est_affectable := false;
end
}
#gen {
do
    F^type := new DTYPE("CHAR", 1);
    F^code_est_adresse := false;
    F^code := F^machine.genCaractere(caractere^txt);
end
}

------------------------------------------------------------------------
-- expression unaire
F -> #aff OPUN  F #type #gen;
#aff {
do
    -- non affectable car operation unaire
    F^est_affectable := false;
end
}
#type {
do
    -- controle de type
    if ~F1^type.compareTo(OPUN^type) then
        error(B_10, OPUN^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := F1^type;         
    end 
  
end
}
#gen {
do
    F^code_est_adresse := false;
    -- remontee du code pour prendre en compte l operateur unaire
    -- on empile d abord la valeur puis on fait un SUBR op
    F^code := F1^code + OPUN^code;
end
}

------------------------------------------------------------------------
-- operateurs unaires
OPUN -> plus #type;
#type {
do
    OPUN^type := new DTYPE("OPUNPLUS");
    -- SUBR op
    OPUN^code := "";
end
}

------------------------------------------------------------------------
OPUN -> moins #type;
#type {
do
    OPUN^type := new DTYPE("OPUNMOINS");
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("Ineg");
end
}

------------------------------------------------------------------------
OPUN -> non #type;
#type {
do
    OPUN^type := new DTYPE("OPUNNON");
    -- SUBR op
    OPUN^code := OPUN^machine.genOp("BNeg");    
end
}

------------------------------------------------------------------------
-- pointeur NULL
F -> null #aff #type ;
#aff {
do
    -- non affectable car pointeur null
    F^est_affectable := false;
end
}
#type {
do
    F^type := new DTYPE("int", 1);
    F^code_est_adresse := false;
    F^code := "";
end
}

------------------------------------------------------------------------
-- expression parenthesee
F ->  paro E parf #addr FX #aff #type #gen;
#addr {
do
    F^code_est_adresse := E^code_est_adresse;
    -- type de FX est le type de l expression de gauche
    FX^htype := E^type;
end
}
#aff {
do
    F^est_affectable := (E^est_affectable && FX^est_affectable);
end
}
#type {
do
    -- controle de type
    if ~E^type.compareTo(FX^type) then
        error(B_12, E^type.getNom(), FX^type.getNom());
    else
    -- on remonte le type
        F^type := E^type;         
    end 
  
end
}
#gen {
do
    
    -- GC
    F^code := E^code + FX^code;
end
}

------------------------------------------------------------------------
F ->  paro TYPE parf  F #aff #type #gen;
#aff {
do
    F^est_affectable := F1^est_affectable;
end
}
#type {
do
    -- controle de type
    if ~TYPE^type.compareTo(F1^type) then
        error(B_12, TYPE^type.getNom(), F1^type.getNom());
    else
    -- on remonte le type
        F^type := TYPE^type;         
    end 
end
}
#gen {
do
    -- remontee des infos
    F^code := F1^code;
    F^code_est_adresse := F1^code_est_adresse;
end
}

------------------------------------------------------------------------
F -> mult F #aff #type #addr;
#aff {
do
    F^est_affectable := F1^est_affectable;
end
}
#type {
do
    match F1^type with POINTEUR then
        F^type := F1^type;
        F^code_est_adresse := true;
    else
        error(not_pointeur, F1^type.getNom());
    end        
end
}
#addr {
do
    -- code acces a un pointeur
    F^code := F^machine.genReadIndirectMem(1);
end
}

------------------------------------------------------------------------
F -> ident #htype FX #aff #gen;
global 
  iv : INFOVAR ;
  infofonc : INFOFONC;
  t : DTYPE;
  tdsParam : TDS;
#htype {
local
    i:INFO;
    code : STRING;
do
    i := F^tds.chercherGlobalement(ident^txt);
    if i = null then
        error(B_01, ident^txt);
    end
    match i 
    with INFOVAR then
        iv := i;
        t := iv.getType();
        F^code_est_adresse := true;
    with INFOFONC then
       infofonc := i;
       tdsParam := infofonc.getParams();   
       t := tdsParam.get(1);
       F^code_est_adresse := false;  
    else
        error(B_08, ident^txt);
    end
    FX^htype := t;
end
}  
#aff {
do
    F^est_affectable := FX^est_affectable;
end
}  
#gen{
do
    F^type := FX^type;
    F^code := FX^code;    
end
}

------------------------------------------------------------------------
FX -> #aff #gen;
#aff {
do
    FX^est_affectable := true;
end
}
#gen {
do
  FX^type := FX^htype;
  FX^code := "";
end
}

------------------------------------------------------------------------
-- acces champ
FX ->   pt  ident #a FX #aff #gen;
#aff {
do
    FX^est_affectable := FX1^est_affectable;
end
}
#gen {
do
  FX^type := FX1^type;
  FX^code :=FX1^code;
end
}
#a {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do


end
}

------------------------------------------------------------------------
-- acces champ pointeur
FX ->   arrow  ident FX #aff #type #gen;
#aff {
do
    FX^est_affectable := FX1^est_affectable;
end
}
#type {
do
    FX^type := FX1^type;    
end
}
#gen {
do
    FX^code := "";        
end
}

------------------------------------------------------------------------
-- appel de sous-programme
FX ->   paro #tds ES parf FX #aff #type #gen;
global 
    tdsParam :  TDS; 
#tds {
do
    --création d'une TDS pour stocker les param de l'appel
    tdsParam := new TDS(FX^tds);
    ES^tds := tdsParam; 
    FX1^tds := new TDS(tdsParam);
end
}
#aff {
do
    -- pour l instant on ne gere pas l affectation multiple
    FX^est_affectable := false;
end
}
#type {
do
    FX^type := FX1^type;
end
}   
#gen {
do
    -- appel du sous-programme à partir de l'étiquette
    FX^code := FX^machine.genCall();
end
}

------------------------------------------------------------------------
-- arguments appel de sous-programme
ES -> ;
-- Done

------------------------------------------------------------------------
ES -> #tds E ESX  ;
global
    tds:TDS;
#tds {
do
    tds := new TDS(ES^tds);
    E^tds := tds;
    ESX^tds := tds;
    
end
}

------------------------------------------------------------------------
ESX ->  ;
-- Tds done


------------------------------------------------------------------------
ESX -> #tds virg E ESX ;
#tds {
do 
    -- transmission des tds;
    E^tds := ESX^tds;
    ESX1^tds := ESX^tds;
end
}

------------------------------------------------------------------------
------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := ASM^code_asm;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^code := ASM^code_asm;
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end

