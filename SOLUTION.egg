-----------------------------------------------
-- BLOC 
-- semantique : tds + verification de type
-- + adresses + code
-----------------------------------------------
option auto= true;
option version = 0.0.1 ; 
option k=2;

inh tam : TAM for BLOC, INSTS,  INST, TERME, FACTEUR, FX, TERMES, APPEL;
inh source : BLOCSourceFile for PROG ; 
inh tds    : TDS     for BLOC, INST, INSTS, TERME, FACTEUR, TYPE , CHAMPS, TERMES,APPEL;
syn type   : DTYPE   for TYPE, TERME, FACTEUR, FX;
inh htype   : DTYPE   for  FX;
inh champs : LCHAMPS for CHAMPS;
inh types : LTYPES for  TERMES;
inh hdep : INTEGER for BLOC, INSTS, INST , CHAMPS;
syn dep : INTEGER for INST , INSTS;
syn code : STRING for BLOC, INSTS, INST, TERME, FACTEUR, FX, TERMES, APPEL;
inh hcode : STRING for FX;
-- Cet attribut indique si le code genere est une adresse ou non
-- permet de ne pas generer d'adresse pour les constantes.
-- Rmq : n'est pas utile pour TERME puisque TERME n'apparaissant
-- jamais en partie gauche d'une affectation, son code n'est JAMAIS
-- généré comme une adresse
syn code_est_adresse : BOOLEAN for  FACTEUR, FX ;
inh hcode_est_adresse : BOOLEAN for FX ;
-- Cet attribut sert a calculer les adresses STATIQUEMENT
-- lorsque cela est possible. Vaut 0 si valeur non significative.
-- Cet attribut est calcule systématiquement en attendant de
-- savoir s'il est utile ou non ...
syn adresse : INTEGER for  FACTEUR, FX ; 
inh hadresse : INTEGER for FX ;
-- on pourrait utiliser une valeur particulière (c'est-a-dire non valide !)
-- de l'adresse pour indiquer qu'on ne tient pas compte de l'adresse
-- mais il vaut mieux utiliser un booleen adresse_utile
syn adresse_utile : BOOLEAN for  FACTEUR, FX ; 
inh hadresse_utile : BOOLEAN for FX ;

inh type_par: DTYPE for APPEL, BLOC, INST, INSTS;
inh proc: STRING for APPEL, BLOC, INST, INSTS;

space  separateur  is    "[\n\r\t ]+";
space  comments    is    "\/\/.*[\n\r]"; 
sugar  aco         is    "\{";
sugar  acf         is    "\}";
sugar  paro        is    "\(";
sugar  parf        is    "\)";
sugar  pv          is    ";";
sugar  v           is    ",";
sugar  aff         is    "=";
sugar  struct      is    "struct" ;
sugar  pt          is    "\." ;
sugar  etoile      is    "\*" ;
sugar  new         is    "new" ;
sugar  type        is    "type" ;
sugar  vrai        is    "true";
sugar  faux        is    "false";
sugar  si          is    "if";
sugar  sinon       is    "else";
sugar  int         is    "int";
sugar  bool        is    "bool";
term   entier      is    "[0-9]+";
term   ident       is    "[A-Za-z_]+";

PROG -> ident #tds paro TYPE ident parf #par BLOC  APPEL #gen  ;
global
  tam : TAM; 
  t:TDS;
#tds {
do
   t := new TDS(null);
   BLOC^hdep := 3;
   tam :=  new TAM(PROG^source.getFileName());
   BLOC^tam := tam;
   APPEL^tam := tam;
   BLOC^tds := t;
   APPEL^tds := t;
   BLOC^proc := ident^txt;
   APPEL^proc := ident^txt;
   TYPE^tds := t;
end
}
#par {
local
  iv : INFOVAR ; 
  d : INTEGER;
do
  -- creer une variable pour le parametre (dep =  - taille par)
    d:= TYPE^type.getTaille();
  -- deplacement negatif par rapport a LB
  iv := new INFOVAR(TYPE^type, -d);
  -- insertion
  call t.inserer(ident1^txt,  iv);
--------------------------------------------------
  --   transmettre le TYPE du parametre
  BLOC^type_par := TYPE^type;
  APPEL^type_par := TYPE^type;
--------------------------------------------------
  -- Afficher la table pour information
  write "; tds  par\n" + t;
end
}


#gen{
local
  cp : STRING ; -- code sous la forme d'une fonction
do
   -- generer le prologue et l'epilogue de la fonction
   -- etiquette + taille des parametres + taille retour + code des instructions
   cp := tam.genFonction(ident^txt, TYPE^type.getTaille(), 0, BLOC^code);
   -- ajouter un appel a la fonction en debut de programme
   tam.genAsm(cp, APPEL^code);
end
}

BLOC -> aco #tds INSTS acf #gen ;
global        -- globale aux actions de cette regle
  t : TDS;    -- pour voir la TDS du bloc
#tds {
do
   t :=  new TDS(BLOC^tds);
   INSTS^tds := t;
end
}
#gen {
do
   write "; tds:\n" + t;
   write "; taille des locales = " + (INSTS^dep - BLOC^hdep)+ "\n";
   BLOC^code := INSTS^code + BLOC^tam.genFree(INSTS^dep - BLOC^hdep);
end
}

-------------------------------------------------------
-- les types
-------------------------------------------------------
TYPE -> bool #type ;
#type {
do
  TYPE^type := new DTYPE("booleen", 1);
end
}

TYPE -> int  #type ;
#type {
do
    TYPE^type := new DTYPE("entier", 1);
end
}

-------------------------------------------------------
-- les noms de types 
-------------------------------------------------------
TYPE -> ident  #type ;
#type {
 local
    i : INFO ;
    it : INFOTYPE;
    t : DTYPE;
 do
    -- rechercher l'ident   
    i := TYPE^tds.chercherGlobalement(ident^txt);
    if i = null then
      error(B_01, ident^txt);
    else
       match i
       with INFOTYPE then
         it := i ;
         TYPE^type :=  it.getType();
       else
          error(B_07, ident^txt);
       end
    end
  end
}

-------------------------------------------------------
-- les struct
-------------------------------------------------------
TYPE -> struct aco #ch CHAMPS acf  #type ;
global 
 lc : LCHAMPS ;
#ch {
do
  lc := new LCHAMPS();
  CHAMPS^champs := lc;
  CHAMPS^hdep := 0;
end
}

#type {
 do
   TYPE^type := new STRUCT(lc);
 end
}

CHAMPS -> ;
CHAMPS -> TYPE ident pv #ch CHAMPS ;
#ch {
 local
  c : CHAMP ;
 do
  c := CHAMPS^champs.chercher(ident^txt);
    if c /= null then
       error(B_00, ident^txt);
    else    
      c := new CHAMP(ident^txt, TYPE^type, CHAMPS^hdep);
     CHAMPS^champs.inserer(c);
     CHAMPS1^hdep := CHAMPS^hdep + TYPE^type.getTaille();
    end
 end
}

-------------------------------------------------------
-- Les pointeurs
-------------------------------------------------------
TYPE -> etoile TYPE #type ;
#type {
do
  TYPE^type := new POINTEUR(TYPE1^type);
end
}

-------------------------------------------------------
-- instructions (et declarations)
-------------------------------------------------------
INSTS ->  #gen;
#gen {
do
  INSTS^dep := INSTS^hdep ;
  INSTS^code := "";
end
}

INSTS -> INST #dep INSTS  #gen;
#dep {
do
  --write "@ courante = " + INST^dep + "\n";
  INSTS1^hdep := INST^dep;
end
}

#gen {
do
  INSTS^dep := INSTS1^dep;
  INSTS^code := INST^code + INSTS1^code;
end
}

-------------------------------------------------------
-- Les noms de types (en majuscules)
-------------------------------------------------------
INST -> type ident aff TYPE pv  #gen;
#gen {
local
    i : INFO ;
do
    i := INST^tds.chercherGlobalement(ident^txt);
    if i /= null then
       error(B_00, ident^txt);
    else    
      -- creer un type
     i := new INFOTYPE(TYPE^type);
     INST^tds.inserer(ident^txt,  i);
     INST^dep := INST^hdep ;
     INST^code := "";
    end
end
}

-------------------------------------------------------
-- les variables 
-------------------------------------------------------
INST -> TYPE ident aff TERME pv  #gen;
global 
    i : INFO ;
    iv : INFOVAR ;

#gen {

do
    i := INST^tds.chercherLocalement(ident^txt);
    if i /= null then
      error(B_00, ident^txt);
    elseif ~TYPE^type.compareTo(TERME^type) then
      error(B_02, TYPE^type, TERME^type);
    else
      -- creer une variable
      iv := new INFOVAR(TYPE^type, INST^hdep);
      INST^tds.inserer(ident^txt,  iv);
     INST^dep := INST^hdep + TYPE^type.getTaille();
     INST^code := INST^tam.genDecl(ident^txt, iv, TERME^code);
    end
end
}

-------------------------------------------------------
-- affectations
-------------------------------------------------------
INST -> ident #tds FX aff TERME pv  #gen;
global
    iv : INFOVAR; 
  
  #tds {
local
  t : DTYPE ;
    i : INFO; 
do
    -- rechercher l'ident
    i := INST^tds.chercherGlobalement(ident^txt);
    if i = null then
      error(B_01, ident^txt);
    else 
      match i
      -- une variable ?
      with INFOVAR then
        iv := i;
        t := iv.getType();
        FX^htype := t;
        FX^hcode_est_adresse := true;
        FX^hcode := INST^tam.genAdr(iv.getDep());
        FX^hadresse := iv.getDep();
        FX^hadresse_utile := true;
      else
        -- pas une variable
        error(B_05, ident^txt);
      end 
    end
  end
}

#gen {
local 
  code : STRING;
do
    if ~FX^type.compareTo(TERME^type) then
      error(B_02, FX^type, TERME^type);
    else
      INST^dep := INST^hdep ;
      --
      code :=  INST^tam.genComment("Valeur") + TERME^code ;
      if !FX^adresse_utile then
        code := code + INST^tam.genComment("Adresse") +
                     FX^code + INST^tam.genWriteIndirectMem(FX^type.getTaille());
       else
        code := code + INST^tam.genWriteMem(FX^adresse, FX^type.getTaille());
       end              
      INST^code := code; 
                         
     end
  end
}
--------------------------------------------------
-- Appel de la procedure avec un seul parametre
-- Controler le type du TERME
-- generer le code de l'appel
--------------------------------------------------

APPEL -> ident paro TERME parf pv #gen ;
#gen {
local
  tpar : DTYPE;
do
   -- existence de la procedure appelee ?
   if ident^txt.equals(APPEL^proc) then
   -- controle de type
     if ~TERME^type.compareTo(APPEL^type_par ) then
       error(B_02, APPEL^type_par, TERME^type);
     else
       APPEL^code := APPEL^tam.genCall(ident^txt, TERME^code);
     end
   else
      error(B99, ident^txt);
   end
end
}

-----------------------------------------------------
-- Cette instruction permet d'appeler une procedure
-- dans un bloc
----------------------------------------------------
INST -> APPEL #gen;
#gen {
do
    INST^dep := INST^hdep;
    INST^code := APPEL^code ;
end
}


-------------------------------------------------------
-- Conditionnelle
-------------------------------------------------------
INST -> si paro TERME #type parf BLOC sinon BLOC #gen;
#gen {
do
    INST^dep := INST^hdep;
    INST^code := INST^tam.genIf(TERME^code, BLOC^code, BLOC1^code) ;
end
}

#type {
do
   if ~TERME^type.compareTo(new DTYPE("booleen", 1)) then
      error(B_04, TERME^type);
   end
end
}

-------------------------------------------------------
-- terme = facteur eventuellement qualifie
-------------------------------------------------------
TERME -> FACTEUR #hgen FX #gen;
#hgen {
do
  FX^hcode_est_adresse := FACTEUR^code_est_adresse;
  FX^hcode := FACTEUR^code;
  FX^htype := FACTEUR^type;
  FX^hadresse := FACTEUR^adresse;
  FX^hadresse_utile := FACTEUR^adresse_utile;
end
}

 #gen {
do
  TERME^type := FX^type;
  if FX^adresse_utile then
    TERME^code := TERME^tam.genReadMem(FX^adresse, FX^type.getTaille());
  else
    if FX^code_est_adresse then 
      TERME^code :=  FX^code + TERME^tam.genReadIndirectMem(FX^type.getTaille()); 
    else
      TERME^code := FX^code ;
    end
  end
end
}

-------------------------------------------------------
-- qualificateur 
-------------------------------------------------------
FX -> #gen;
#gen {
do
  FX^type := FX^htype;
  FX^code_est_adresse := FX^hcode_est_adresse;
  FX^code := FX^hcode;
  FX^adresse := FX^hadresse;
  FX^adresse_utile := FX^hadresse_utile;
end
}

FX -> pt ident #a FX  #gen;
#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=FX1^code;
  FX^adresse := FX1^adresse;
  FX^adresse_utile := FX1^adresse_utile;
end
}

#a {
local
 s : STRUCT ;
 c : CHAMP;
 lc : LCHAMPS;
do
  match FX^htype
  with STRUCT then
    s := FX^htype;
    lc := s.getChamps();
    c := lc.chercher(ident^txt);
    if c = null then
      error(B_10, ident^txt) ;
    else
      FX1^htype := c.getType();
      --FX1^hcode_est_adresse := FX^hcode_est_adresse;
      if ! FX^hadresse_utile then
        FX1^hadresse := 0;
        FX1^hadresse_utile := false;
        FX1^hcode :=FX^hcode + FX^tam.genComment("acces champ : " + ident^txt) +
                  FX^tam.genAdrField(c.getDep())  ;
      else
        FX1^hadresse := FX^hadresse + c.getDep();
        FX1^hadresse_utile := true;
        FX1^hcode := FX^tam.genComment("acces champ : " + ident^txt);
      end
    end    
  else
    error(B_09, FX^htype); 
  end

end
}

--------------------------------------------------------------
FX -> etoile #a  FX #gen;
#gen {
do
  FX^type := FX1^type;
  FX^code_est_adresse := true;
  FX^code :=  FX1^code;
  FX^adresse := FX1^adresse;
  FX^adresse_utile := FX1^adresse_utile;
end
}

#a {
local
p : POINTEUR ;
code : STRING;
do
  match FX^htype
  with POINTEUR then
    p := FX^htype;
    FX1^htype := p.getType();
    -- on lit le contenu
    --FX1^hcode_est_adresse := FX^hcode_est_adresse;
    code := FX^tam.genComment("acces zone pointee : ");
    if FX^hadresse_utile then
      code := code + FX^tam.genReadMem(FX^hadresse, p.getTaille());
    else
      code := code + FX^hcode + FX^tam.genReadIndirectMem(1);
    end
    FX1^hcode := code ;
    -- A partir de là, l'adresse n'est plus gérable             
    FX1^hadresse := 0;
    FX1^hadresse_utile := false;
   else
    error(B_11, FX^htype);
  end
end
}


-------------------------------------------------------
-- variable
-------------------------------------------------------
FACTEUR -> ident  #gen;
global 
  iv : INFOVAR ;
  t : DTYPE;
#gen{
local
  i:INFO;
  code : STRING;
do
  i := FACTEUR^tds.chercherGlobalement(ident^txt);
  if i = null then
    error(B_01, ident^txt);
  end
  match i 
  with INFOVAR then
    iv := i;
    t := iv.getType();
    FACTEUR^type := t;
    FACTEUR^code_est_adresse := true;
    code := FACTEUR^tam.genComment("ref var/par "+ ident^txt);
    FACTEUR^adresse := iv.getDep();
    FACTEUR^adresse_utile := true;
    FACTEUR^code :=code;
  else
    error(B_08, ident^txt);
  end
end
}

-------------------------------------------------------
-- Constante entiere
-------------------------------------------------------
FACTEUR -> entier #gen;
#gen {
do
  FACTEUR^type := new DTYPE("entier", 1);
  FACTEUR^code_est_adresse := false;
  FACTEUR^code := FACTEUR^tam.genCst(entier^txt);
  FACTEUR^adresse := 0;
  FACTEUR^adresse_utile := false;
end
}

-------------------------------------------------------
-- constantes booleennes
-------------------------------------------------------
FACTEUR -> vrai #gen;
#gen {
do
  FACTEUR^type := new DTYPE("booleen", 1);
  FACTEUR^code_est_adresse := false;
  FACTEUR^code := FACTEUR^tam.genCst("1");
  FACTEUR^adresse := 0;
  FACTEUR^adresse_utile := false;
 end
}

FACTEUR -> faux #gen;
#gen {
do
  FACTEUR^type := new DTYPE("booleen", 1);
  FACTEUR^code_est_adresse := false;
  FACTEUR^code := FACTEUR^tam.genCst("0");
  FACTEUR^adresse := 0;
  FACTEUR^adresse_utile := false;
end
}

-------------------------------------------------------
--FACTEUR -> paro TERME parf  #gen;
--#gen {
--do
--  FACTEUR^code_est_adresse := TERME^code_est_adresse;
--  FACTEUR^code := TERME^code;
--  FACTEUR^type := TERME^type;
--end
--}

-------------------------------------------------------
-- init pointeur
-------------------------------------------------------
FACTEUR -> new TYPE paro parf #gen;
#gen {
do
   FACTEUR^type := new POINTEUR(TYPE^type);
   FACTEUR^code_est_adresse := false;
   FACTEUR^code := FACTEUR^tam.genMalloc(TYPE^type.getTaille());
   FACTEUR^adresse := 0;
  FACTEUR^adresse_utile := false;
end
}

-------------------------------------------------------
-- Liste de termes pour initialiser un struct
-- le type de facteur est TUPLE
-------------------------------------------------------
FACTEUR -> aco #a TERME TERMES acf  #gen;
global
  lt : LTYPES ;
  
#a {
do
  lt := new LTYPES();
  TERMES^types := lt;
end
}


#gen {
do
  lt.inserer(TERME^type);
  FACTEUR^type := new TUPLE(lt);
  FACTEUR^code_est_adresse := false;
  FACTEUR^code := TERME^code + TERMES^code; 
  FACTEUR^adresse := 0;
  FACTEUR^adresse_utile := false;
end
}

TERMES ->  #gen;
#gen {
do
  TERMES^code := "";
end
}


TERMES -> v TERME TERMES #gen;
#gen {
do
  TERMES^code := TERME^code + TERMES1^code;
  TERMES^types.add(TERME^type);
 
end
}
-------------------------------------------------------

end
